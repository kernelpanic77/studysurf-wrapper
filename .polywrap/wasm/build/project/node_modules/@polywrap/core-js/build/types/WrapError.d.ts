import { CleanResolutionStep } from "../algorithms";
export declare type ErrorSource = Readonly<{
    file?: string;
    row?: number;
    col?: number;
}>;
/**
 Wrap error codes provide additional context to WrapErrors.
 Error code naming convention (approximate):
 type of handler
 type of functionality
 piece of functionality
 ==> handler_typeFn_pieceFn
 Error code map:
 0 -> Invalid
 1-25 -> Client
 26-50 -> URI resolution
 51-75 -> Wrapper invocation & sub-invocation
 76-255 -> Unallocated
 */
export declare enum WrapErrorCode {
    CLIENT_LOAD_WRAPPER_ERROR = 1,
    CLIENT_GET_FILE_ERROR = 2,
    CLIENT_GET_IMPLEMENTATIONS_ERROR = 3,
    CLIENT_VALIDATE_RESOLUTION_FAIL = 4,
    CLIENT_VALIDATE_ABI_FAIL = 5,
    CLIENT_VALIDATE_RECURSIVE_FAIL = 6,
    URI_RESOLUTION_ERROR = 26,
    URI_RESOLVER_ERROR = 27,
    URI_NOT_FOUND = 28,
    WRAPPER_INVOKE_ABORTED = 51,
    WRAPPER_SUBINVOKE_ABORTED = 52,
    WRAPPER_INVOKE_FAIL = 53,
    WRAPPER_READ_FAIL = 54,
    WRAPPER_INTERNAL_ERROR = 55,
    WRAPPER_METHOD_NOT_FOUND = 56,
    WRAPPER_ARGS_MALFORMED = 57
}
export interface WrapErrorOptions {
    code: WrapErrorCode;
    uri: string;
    method?: string;
    args?: string;
    source?: ErrorSource;
    resolutionStack?: CleanResolutionStep;
    cause?: unknown;
    innerError?: WrapError;
}
export declare class WrapError extends Error {
    readonly name: string;
    readonly code: WrapErrorCode;
    readonly reason: string;
    readonly uri: string;
    readonly method?: string;
    readonly args?: string;
    readonly source?: ErrorSource;
    readonly resolutionStack?: CleanResolutionStep;
    readonly cause?: unknown;
    readonly innerError?: WrapError;
    constructor(reason: string | undefined, options: WrapErrorOptions);
    private static re;
    static parse(error: string): WrapError | undefined;
    toString(): string;
    private static sanitizeUnwrappedRustResult;
    private static _parse;
    private static stringify;
    private static stringifyCause;
}
