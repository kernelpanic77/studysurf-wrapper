"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WrapError = exports.WrapErrorCode = void 0;
/**
 Wrap error codes provide additional context to WrapErrors.
 Error code naming convention (approximate):
 type of handler
 type of functionality
 piece of functionality
 ==> handler_typeFn_pieceFn
 Error code map:
 0 -> Invalid
 1-25 -> Client
 26-50 -> URI resolution
 51-75 -> Wrapper invocation & sub-invocation
 76-255 -> Unallocated
 */
var WrapErrorCode;
(function (WrapErrorCode) {
    WrapErrorCode[WrapErrorCode["CLIENT_LOAD_WRAPPER_ERROR"] = 1] = "CLIENT_LOAD_WRAPPER_ERROR";
    WrapErrorCode[WrapErrorCode["CLIENT_GET_FILE_ERROR"] = 2] = "CLIENT_GET_FILE_ERROR";
    WrapErrorCode[WrapErrorCode["CLIENT_GET_IMPLEMENTATIONS_ERROR"] = 3] = "CLIENT_GET_IMPLEMENTATIONS_ERROR";
    WrapErrorCode[WrapErrorCode["CLIENT_VALIDATE_RESOLUTION_FAIL"] = 4] = "CLIENT_VALIDATE_RESOLUTION_FAIL";
    WrapErrorCode[WrapErrorCode["CLIENT_VALIDATE_ABI_FAIL"] = 5] = "CLIENT_VALIDATE_ABI_FAIL";
    WrapErrorCode[WrapErrorCode["CLIENT_VALIDATE_RECURSIVE_FAIL"] = 6] = "CLIENT_VALIDATE_RECURSIVE_FAIL";
    WrapErrorCode[WrapErrorCode["URI_RESOLUTION_ERROR"] = 26] = "URI_RESOLUTION_ERROR";
    WrapErrorCode[WrapErrorCode["URI_RESOLVER_ERROR"] = 27] = "URI_RESOLVER_ERROR";
    WrapErrorCode[WrapErrorCode["URI_NOT_FOUND"] = 28] = "URI_NOT_FOUND";
    WrapErrorCode[WrapErrorCode["WRAPPER_INVOKE_ABORTED"] = 51] = "WRAPPER_INVOKE_ABORTED";
    WrapErrorCode[WrapErrorCode["WRAPPER_SUBINVOKE_ABORTED"] = 52] = "WRAPPER_SUBINVOKE_ABORTED";
    WrapErrorCode[WrapErrorCode["WRAPPER_INVOKE_FAIL"] = 53] = "WRAPPER_INVOKE_FAIL";
    WrapErrorCode[WrapErrorCode["WRAPPER_READ_FAIL"] = 54] = "WRAPPER_READ_FAIL";
    WrapErrorCode[WrapErrorCode["WRAPPER_INTERNAL_ERROR"] = 55] = "WRAPPER_INTERNAL_ERROR";
    WrapErrorCode[WrapErrorCode["WRAPPER_METHOD_NOT_FOUND"] = 56] = "WRAPPER_METHOD_NOT_FOUND";
    WrapErrorCode[WrapErrorCode["WRAPPER_ARGS_MALFORMED"] = 57] = "WRAPPER_ARGS_MALFORMED";
})(WrapErrorCode = exports.WrapErrorCode || (exports.WrapErrorCode = {}));
var WrapError = /** @class */ (function (_super) {
    __extends(WrapError, _super);
    function WrapError(reason, options) {
        if (reason === void 0) { reason = "Encountered an exception."; }
        var _this = _super.call(this, WrapError.stringify(reason, options)) || this;
        _this.name = "WrapError";
        _this.code = options.code;
        _this.reason = reason;
        _this.uri = options.uri;
        _this.method = options.method;
        _this.args = options.args;
        _this.source = options.source;
        _this.resolutionStack = options.resolutionStack;
        _this.cause = options.cause;
        _this.innerError = options.innerError;
        Object.setPrototypeOf(_this, WrapError.prototype);
        Error.captureStackTrace(_this, _this.constructor);
        return _this;
    }
    WrapError.parse = function (error) {
        error = WrapError.sanitizeUnwrappedRustResult(error);
        var delim = "\n\nAnother exception was encountered during execution:\n";
        var errorStrings = error.split(delim);
        // case: single WrapError or not a WrapError
        if (errorStrings.length === 1) {
            var args = WrapError._parse(error);
            return args ? new WrapError(args.reason, args.options) : undefined;
        }
        // case: stack of WrapErrors stringified
        var errArgs = errorStrings.map(WrapError._parse);
        // iterate through args to assign `cause` and `prev`
        var curr = undefined;
        for (var i = errArgs.length - 1; i >= 0; i--) {
            var currArgs = errArgs[i];
            if (!currArgs) {
                // should only happen if a user includes the delimiter in their error message
                throw new Error("Failed to parse WrapError");
            }
            curr = new WrapError(currArgs.reason, __assign(__assign({}, currArgs.options), { innerError: curr }));
        }
        return curr;
    };
    WrapError.prototype.toString = function () {
        return this.name + ": " + this.message;
    };
    // remove escape characters that may have been added by Rust
    WrapError.sanitizeUnwrappedRustResult = function (error) {
        if (error.startsWith('__wrap_abort: called `Result::unwrap()` on an `Err` value: "')) {
            error = error.replace(/\\"/g, '"');
            error = error.replace(/\\n/g, "\n");
        }
        return error;
    };
    // parse a single WrapError, where the 'prev' property is undefined
    WrapError._parse = function (error) {
        var result = WrapError.re.exec(error);
        if (!result) {
            return undefined;
        }
        var _a = result.groups, codeStr = _a.code, reason = _a.reason, uri = _a.uri, method = _a.method, args = _a.args, file = _a.file, row = _a.row, col = _a.col, resolutionStackStr = _a.resolutionStack, cause = _a.cause;
        var code = parseInt(codeStr);
        var source = file
            ? {
                file: file,
                row: row ? parseInt(row) : undefined,
                col: col ? parseInt(col) : undefined,
            }
            : undefined;
        var resolutionStack = resolutionStackStr
            ? JSON.parse(resolutionStackStr)
            : undefined;
        return {
            reason: reason,
            options: {
                code: code,
                uri: uri,
                method: method,
                args: args === null || args === void 0 ? void 0 : args.trim(),
                source: source,
                resolutionStack: resolutionStack,
                cause: cause,
            },
        };
    };
    WrapError.stringify = function (reason, options) {
        var code = options.code, uri = options.uri, method = options.method, args = options.args, source = options.source, resolutionStack = options.resolutionStack, cause = options.cause, innerError = options.innerError;
        var formattedCode = code + " " + WrapErrorCode[code].replace(/_/g, " ");
        // Some items are not always present
        var maybeMethod = method ? "method: " + method : "";
        var maybeArgs = args ? "args: " + args + " " : "";
        // source is uses () instead of {} to facilitate regex
        var maybeSource = source
            ? "source: { file: \"" + (source === null || source === void 0 ? void 0 : source.file) + "\", row: " + (source === null || source === void 0 ? void 0 : source.row) + ", col: " + (source === null || source === void 0 ? void 0 : source.col) + " }"
            : "";
        var maybeResolutionStack = resolutionStack
            ? "uriResolutionStack: " + JSON.stringify(resolutionStack, null, 2)
            : "";
        var errorCause = WrapError.stringifyCause(cause);
        var maybeCause = errorCause
            ? "\nThis exception was caused by the following exception:\n" + errorCause
            : "";
        var maybeDelim = innerError
            ? "\nAnother exception was encountered during execution:\n" + innerError
            : "";
        return [
            "" + reason,
            "code: " + formattedCode,
            "uri: " + uri,
            maybeMethod,
            maybeArgs,
            maybeSource,
            maybeResolutionStack,
            maybeCause,
            maybeDelim,
        ]
            .filter(function (it) { return !!it; })
            .join("\n");
    };
    WrapError.stringifyCause = function (cause) {
        if (cause === undefined || cause === null) {
            return undefined;
        }
        else if (cause instanceof Error) {
            return cause.toString();
        }
        else if (typeof cause === "object" && cause) {
            if (cause.toString !== Object.prototype.toString &&
                typeof cause.toString === "function") {
                return cause.toString();
            }
            return JSON.stringify(cause);
        }
        else if (typeof cause === "function" &&
            cause.toString !== Object.prototype.toString &&
            typeof cause.toString === "function") {
            return cause.toString();
        }
        else {
            return "" + cause;
        }
    };
    WrapError.re = new RegExp([
        /^(?:[A-Za-z_:()` ]*;? "?)?WrapError: (?<reason>(?:.|\r|\n)*)/.source,
        // there is some padding added to the number of words expected in an error code
        /(?:\r\n|\r|\n)code: (?<code>1?[0-9]{1,2}|2[0-4][0-9]|25[0-5]) (?:[A-Z]+ ?){1,5}/
            .source,
        /(?:\r\n|\r|\n)uri: (?<uri>wrap:\/\/[A-Za-z0-9_-]+\/.+)/.source,
        /(?:(?:\r\n|\r|\n)method: (?<method>([A-Za-z_]{1}[A-Za-z0-9_]*)))?/
            .source,
        /(?:(?:\r\n|\r|\n)args: (?<args>\{(?:.|\r|\n)+} ))?/.source,
        /(?:(?:\r\n|\r|\n)source: \{ file: "(?<file>.+)", row: (?<row>[0-9]+), col: (?<col>[0-9]+) })?/
            .source,
        /(?:(?:\r\n|\r|\n)uriResolutionStack: (?<resolutionStack>\[(?:.|\r|\n)+]))?/
            .source,
        /(?:(?:\r\n|\r|\n){2}This exception was caused by the following exception:(?:\r\n|\r|\n)(?<cause>(?:.|\r|\n)+))?/
            .source,
        /"?$/.source,
    ].join(""));
    return WrapError;
}(Error));
exports.WrapError = WrapError;
//# sourceMappingURL=WrapError.js.map