"use strict";
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.writeDirectorySync = exports.readDirectorySync = void 0;
var file_1 = require("./file");
var sort_1 = require("./sort");
var path_1 = __importDefault(require("path"));
var fs_1 = require("fs");
// TODO: make this all async, making it run faster
function readDirectorySync(dir) {
    var importDirectoryEntry = function (root, dirent) {
        var direntPath = path_1.default.join(root, dirent.name);
        if (dirent.isDirectory()) {
            var entries_1 = fs_1.readdirSync(direntPath, {
                withFileTypes: true,
            })
                .sort(sort_1.alphabeticalNamedSort)
                .map(function (dirent) { return importDirectoryEntry(direntPath, dirent); });
            return {
                type: "Directory",
                name: dirent.name,
                data: entries_1,
            };
        }
        else {
            return {
                type: "File",
                name: dirent.name,
                data: fs_1.readFileSync(direntPath, { encoding: "utf-8" }),
            };
        }
    };
    var entries = fs_1.readdirSync(dir, {
        withFileTypes: true,
    })
        .sort(sort_1.alphabeticalNamedSort)
        .map(function (dirent) { return importDirectoryEntry(dir, dirent); });
    return { entries: entries };
}
exports.readDirectorySync = readDirectorySync;
function writeDirectorySync(outputDir, dir, renderTemplate) {
    var e_1, _a;
    var paths = [];
    var outputDirectoryEntry = function (root, entry) {
        var e_2, _a;
        var entryPath = path_1.default.join(root, entry.name);
        paths.push(entryPath);
        switch (entry.type) {
            case "File": {
                file_1.writeFileSync(entryPath, entry.data);
                break;
            }
            case "Directory": {
                try {
                    for (var _b = __values(entry.data), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var subEntry = _c.value;
                        if (!fs_1.existsSync(entryPath)) {
                            fs_1.mkdirSync(entryPath, { recursive: true });
                        }
                        outputDirectoryEntry(entryPath, subEntry);
                    }
                }
                catch (e_2_1) { e_2 = { error: e_2_1 }; }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                    }
                    finally { if (e_2) throw e_2.error; }
                }
                break;
            }
            case "Template": {
                if (!renderTemplate) {
                    throw Error("outputDirectoryEntry: No renderTemplate function provided. Found template " + entry.name);
                }
                file_1.writeFileSync(entryPath, renderTemplate(entry.data));
                break;
            }
            default: {
                throw Error("outputDirectoryEntry: Unknown entry type. Entry: " + JSON.stringify(entry));
            }
        }
    };
    try {
        for (var _b = __values(dir.entries), _c = _b.next(); !_c.done; _c = _b.next()) {
            var entry = _c.value;
            outputDirectoryEntry(outputDir, entry);
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return paths;
}
exports.writeDirectorySync = writeDirectorySync;
//# sourceMappingURL=directory.js.map