"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.toWasm = exports.toWasmInit = exports.toMsgPack = exports.detectKeyword = void 0;
var types_1 = require("./types");
// check if any of the keywords match the property name;
// if there's a match, insert `_` at the beginning of the property name.
var detectKeyword = function () {
    return function (value, render) {
        var type = render(value);
        if (types_1.isKeyword(type)) {
            return "_" + type;
        }
        return type;
    };
};
exports.detectKeyword = detectKeyword;
var toMsgPack = function () {
    return function (value, render) {
        var type = render(value);
        var modifier = "";
        if (type[type.length - 1] === "!") {
            type = type.substring(0, type.length - 1);
        }
        else {
            modifier = "Optional";
        }
        if (type[0] === "[") {
            return modifier + "Array";
        }
        if (type.startsWith("Map<")) {
            return modifier + "ExtGenericMap";
        }
        switch (type) {
            case "Int":
                return modifier + "Int32";
            case "UInt":
                return modifier + "UInt32";
            case "Boolean":
                return modifier + "Bool";
            default:
                return modifier + type;
        }
    };
};
exports.toMsgPack = toMsgPack;
var toWasmInit = function () {
    return function (value, render) {
        var type = render(value);
        if (type[type.length - 1] === "!") {
            type = type.substring(0, type.length - 1);
        }
        else {
            var nullType = exports.toWasm()(value, render);
            var nullOptional = "| null";
            if (nullType.endsWith(nullOptional)) {
                return "null";
            }
        }
        if (type[0] === "[") {
            return "[]";
        }
        if (type.startsWith("Map<")) {
            var firstOpenBracketIdx = type.indexOf("<");
            var lastCloseBracketIdx = type.lastIndexOf(">");
            if (firstOpenBracketIdx === -1 || lastCloseBracketIdx === -1) {
                throw new Error("Invalid Map: " + type);
            }
            var keyValTypes = type.substring(firstOpenBracketIdx + 1, lastCloseBracketIdx);
            var firstCommaIdx = keyValTypes.indexOf(",");
            if (firstCommaIdx === -1) {
                throw new Error("Invalid Map: " + type);
            }
            var keyType = keyValTypes.substring(0, firstCommaIdx).trim();
            var valType = keyValTypes.substring(firstCommaIdx + 1).trim();
            var wasmKeyType = exports.toWasm()(keyType, function (str) { return str; });
            var wasmValType = exports.toWasm()(valType, function (str) { return str; });
            return "new Map<" + wasmKeyType + ", " + wasmValType + ">()";
        }
        switch (type) {
            case "Int":
            case "Int8":
            case "Int16":
            case "Int32":
            case "UInt":
            case "UInt8":
            case "UInt16":
            case "UInt32":
                return "0";
            case "String":
                return "\"\"";
            case "Boolean":
                return "false";
            case "Bytes":
                return "new ArrayBuffer(0)";
            case "BigInt":
                return "BigInt.fromUInt16(0)";
            case "BigNumber":
                return "new BigNumber(BigInt.fromUInt16(0), 0, 0)";
            case "JSON":
                return "JSON.Value.Null()";
            default:
                if (type.includes("Enum_")) {
                    return "0";
                }
                else {
                    type = exports.detectKeyword()(type, function (str) { return str; });
                    return "new Types." + type + "()";
                }
        }
    };
};
exports.toWasmInit = toWasmInit;
var toWasm = function () {
    return function (value, render) {
        var type = render(value);
        var isEnum = false;
        var optional = false;
        if (type[type.length - 1] === "!") {
            type = type.substring(0, type.length - 1);
        }
        else {
            optional = true;
        }
        if (type[0] === "[") {
            return toWasmArray(type, optional);
        }
        if (type.startsWith("Map<")) {
            return toWasmMap(type, optional);
        }
        switch (type) {
            case "Int":
                type = "i32";
                break;
            case "Int8":
                type = "i8";
                break;
            case "Int16":
                type = "i16";
                break;
            case "Int32":
                type = "i32";
                break;
            case "UInt":
            case "UInt32":
                type = "u32";
                break;
            case "UInt8":
                type = "u8";
                break;
            case "UInt16":
                type = "u16";
                break;
            case "String":
                type = "string";
                break;
            case "Boolean":
                type = "bool";
                break;
            case "Bytes":
                type = "ArrayBuffer";
                break;
            case "BigInt":
                type = "BigInt";
                break;
            case "BigNumber":
                type = "BigNumber";
                break;
            case "JSON":
                type = "JSON.Value";
                break;
            default:
                if (type.includes("Enum_")) {
                    type = type.replace("Enum_", "");
                    isEnum = true;
                }
                type = exports.detectKeyword()(type, function (str) { return str; });
                type = "Types." + type;
        }
        return applyOptional(type, optional, isEnum);
    };
};
exports.toWasm = toWasm;
var toWasmArray = function (type, optional) {
    var result = type.match(/(\[)([[\]A-Za-z0-9_.!]+)(\])/);
    if (!result || result.length !== 4) {
        throw Error("Invalid Array: " + type);
    }
    var wasmType = exports.toWasm()(result[2], function (str) { return str; });
    return applyOptional("Array<" + wasmType + ">", optional, false);
};
var toWasmMap = function (type, optional) {
    var firstOpenBracketIdx = type.indexOf("<");
    var lastCloseBracketIdx = type.lastIndexOf(">");
    if (firstOpenBracketIdx === -1 || lastCloseBracketIdx === -1) {
        throw new Error("Invalid Map: " + type);
    }
    var keyValTypes = type.substring(firstOpenBracketIdx + 1, lastCloseBracketIdx);
    var firstCommaIdx = keyValTypes.indexOf(",");
    if (firstCommaIdx === -1) {
        throw new Error("Invalid Map: " + type);
    }
    var keyType = keyValTypes.substring(0, firstCommaIdx).trim();
    var valType = keyValTypes.substring(firstCommaIdx + 1).trim();
    var wasmKeyType = exports.toWasm()(keyType, function (str) { return str; });
    var wasmValType = exports.toWasm()(valType, function (str) { return str; });
    return applyOptional("Map<" + wasmKeyType + ", " + wasmValType + ">", optional, false);
};
var applyOptional = function (type, optional, isEnum) {
    if (optional) {
        if (type.indexOf("Array") === 0 ||
            type.indexOf("string") === 0 ||
            (!isEnum && !types_1.isBaseType(type))) {
            return type + " | null";
        }
        else {
            return "Box<" + type + "> | null";
        }
    }
    else {
        return type;
    }
};
//# sourceMappingURL=functions.js.map