"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.serdeKeyword = exports.detectKeyword = exports.toWasm = exports.toWasmInit = exports.toMsgPack = exports.noBox = exports.toUpper = exports.toLower = void 0;
var types_1 = require("./types");
function replaceAt(str, index, replacement) {
    return (str.substr(0, index) + replacement + str.substr(index + replacement.length));
}
function insertAt(str, index, insert) {
    return str.substr(0, index) + insert + str.substr(index);
}
function removeAt(str, index) {
    return str.substr(0, index) + str.substr(index + 1);
}
var toLower = function () {
    return function (value, render) {
        var type = render(value);
        for (var i = 0; i < type.length; ++i) {
            var char = type.charAt(i);
            var lower = char.toLowerCase();
            if (char !== lower) {
                // Replace the uppercase char w/ the lowercase version
                type = replaceAt(type, i, lower);
                if (i !== 0 && type[i - 1] !== "_") {
                    // Make sure all lowercase conversions have an underscore before them
                    type = insertAt(type, i, "_");
                }
            }
        }
        return type;
    };
};
exports.toLower = toLower;
var toUpper = function () {
    return function (value, render) {
        var type = render(value);
        // First character must always be upper case
        var firstChar = type.charAt(0);
        var firstUpper = firstChar.toUpperCase();
        type = replaceAt(type, 0, firstUpper);
        // Look for any underscores, remove them if they exist, and make next letter uppercase
        for (var i = 0; i < type.length; ++i) {
            var char = type.charAt(i);
            if (char === "_") {
                var nextChar = type.charAt(i + 1);
                var nextCharUpper = nextChar.toUpperCase();
                type = replaceAt(type, i + 1, nextCharUpper);
                type = removeAt(type, i);
            }
        }
        return type;
    };
};
exports.toUpper = toUpper;
var noBox = function () {
    return function (value, render) {
        var type = render(value);
        var extract = /(.*)Box<([a-zA-Z0-9]*)>(.*)/gm;
        var match = __spread(type.matchAll(extract));
        if (match.length === 0) {
            return type;
        }
        var strings = match[0];
        return strings[1] + strings[2] + strings[3];
    };
};
exports.noBox = noBox;
var toMsgPack = function () {
    return function (value, render) {
        var type = render(value);
        var modifier = "";
        if (type[type.length - 1] === "!") {
            type = type.substr(0, type.length - 1);
        }
        else {
            modifier = "optional_";
        }
        if (type[0] === "[") {
            return modifier + "array";
        }
        if (type.startsWith("Map<")) {
            return modifier + "ext_generic_map";
        }
        switch (type) {
            case "Int":
                return modifier + "i32";
            case "Int8":
                return modifier + "i8";
            case "Int16":
                return modifier + "i16";
            case "Int32":
                return modifier + "i32";
            case "Int64":
                return modifier + "i64";
            case "UInt":
            case "UInt32":
                return modifier + "u32";
            case "UInt8":
                return modifier + "u8";
            case "UInt16":
                return modifier + "u16";
            case "UInt64":
                return modifier + "u64";
            case "String":
                return modifier + "string";
            case "Boolean":
                return modifier + "bool";
            case "Bytes":
                return modifier + "bytes";
            case "BigInt":
                return modifier + "bigint";
            case "BigNumber":
                return modifier + "bignumber";
            case "JSON":
                return modifier + "json";
            default:
                throw Error("Unknown toWasm type \"" + type + "\"");
        }
    };
};
exports.toMsgPack = toMsgPack;
var toWasmInit = function () {
    return function (value, render) {
        var type = render(value);
        var optional = false;
        var optionalModifier = function (str) {
            return !optional ? str : "None";
        };
        if (type[type.length - 1] === "!") {
            type = type.substr(0, type.length - 1);
        }
        else {
            optional = true;
        }
        if (type[0] === "[") {
            return optionalModifier("vec![]");
        }
        if (type.startsWith("Map<")) {
            var firstOpenBracketIdx = type.indexOf("<");
            var lastCloseBracketIdx = type.lastIndexOf(">");
            if (firstOpenBracketIdx === -1 || lastCloseBracketIdx === -1) {
                throw new Error("Invalid Map: " + type);
            }
            var keyValTypes = type.substring(firstOpenBracketIdx + 1, lastCloseBracketIdx);
            var firstCommaIdx = keyValTypes.indexOf(",");
            if (firstCommaIdx === -1) {
                throw new Error("Invalid Map: " + type);
            }
            var keyType = keyValTypes.substring(0, firstCommaIdx).trim();
            var valType = keyValTypes.substring(firstCommaIdx + 1).trim();
            var wasmKeyType = exports.toWasm()(keyType, function (str) { return str; });
            var wasmValType = exports.toWasm()(valType, function (str) { return str; });
            return optionalModifier("Map::<" + wasmKeyType + ", " + wasmValType + ">::new()");
        }
        switch (type) {
            case "Int":
            case "Int8":
            case "Int16":
            case "Int32":
            case "Int64":
            case "UInt":
            case "UInt8":
            case "UInt16":
            case "UInt32":
            case "UInt64":
                return optionalModifier("0");
            case "String":
                return optionalModifier("String::new()");
            case "Boolean":
                return optionalModifier("false");
            case "Bytes":
                return optionalModifier("vec![]");
            case "BigInt":
                return optionalModifier("BigInt::default()");
            case "BigNumber":
                return optionalModifier("BigNumber::default()");
            case "JSON":
                return optionalModifier("JSON::Value::Null");
            default:
                if (type.includes("Enum_")) {
                    return optionalModifier(exports.toWasm()(value, render) + "::_MAX_");
                }
                else {
                    return optionalModifier(exports.toWasm()(value, render) + "::new()");
                }
        }
    };
};
exports.toWasmInit = toWasmInit;
var toWasm = function () {
    return function (value, render) {
        var type = render(value);
        var optional = false;
        if (type[type.length - 1] === "!") {
            type = type.substr(0, type.length - 1);
        }
        else {
            optional = true;
        }
        if (type[0] === "[") {
            return toWasmArray(type, optional);
        }
        if (type.startsWith("Map<")) {
            return toWasmMap(type, optional);
        }
        switch (type) {
            case "Int":
                type = "i32";
                break;
            case "Int8":
                type = "i8";
                break;
            case "Int16":
                type = "i16";
                break;
            case "Int32":
                type = "i32";
                break;
            case "Int64":
                type = "i64";
                break;
            case "UInt":
            case "UInt32":
                type = "u32";
                break;
            case "UInt8":
                type = "u8";
                break;
            case "UInt16":
                type = "u16";
                break;
            case "UInt64":
                type = "u64";
                break;
            case "String":
                type = "String";
                break;
            case "Boolean":
                type = "bool";
                break;
            case "Bytes":
                type = "Vec<u8>";
                break;
            case "BigInt":
                type = "BigInt";
                break;
            case "BigNumber":
                type = "BigNumber";
                break;
            case "JSON":
                type = "JSON::Value";
                break;
            default:
                if (type.includes("Enum_")) {
                    type = type.replace("Enum_", "");
                }
                type = exports.toUpper()(type, function (str) { return str; });
                type = exports.detectKeyword()(type, function (str) { return str; });
        }
        return applyOptional(type, optional);
    };
};
exports.toWasm = toWasm;
// check if any of the keywords match the property name;
// if there's a match, insert `_` at the beginning of the property name.
var detectKeyword = function () {
    return function (value, render) {
        var type = render(value);
        if (types_1.isKeyword(type)) {
            return "_" + type;
        }
        return type;
    };
};
exports.detectKeyword = detectKeyword;
var serdeKeyword = function () {
    return function (value, render) {
        var type = render(value);
        if (types_1.isKeyword(type)) {
            return "#[serde(rename = \"" + type + "\")]\n    ";
        }
        return "";
    };
};
exports.serdeKeyword = serdeKeyword;
var toWasmArray = function (type, optional) {
    var result = type.match(/(\[)([[\]A-Za-z1-9_.!]+)(\])/);
    if (!result || result.length !== 4) {
        throw Error("Invalid Array: " + type);
    }
    var wasmType = exports.toWasm()(result[2], function (str) { return str; });
    return applyOptional("Vec<" + wasmType + ">", optional);
};
var toWasmMap = function (type, optional) {
    var firstOpenBracketIdx = type.indexOf("<");
    var lastCloseBracketIdx = type.lastIndexOf(">");
    if (firstOpenBracketIdx === -1 || lastCloseBracketIdx === -1) {
        throw new Error("Invalid Map: " + type);
    }
    var keyValTypes = type.substring(firstOpenBracketIdx + 1, lastCloseBracketIdx);
    var firstCommaIdx = keyValTypes.indexOf(",");
    if (firstCommaIdx === -1) {
        throw new Error("Invalid Map: " + type);
    }
    var keyType = keyValTypes.substring(0, firstCommaIdx).trim();
    var valType = keyValTypes.substring(firstCommaIdx + 1).trim();
    var wasmKeyType = exports.toWasm()(keyType, function (str) { return str; });
    var wasmValType = exports.toWasm()(valType, function (str) { return str; });
    return applyOptional("Map<" + wasmKeyType + ", " + wasmValType + ">", optional);
};
var applyOptional = function (type, optional) {
    if (optional) {
        return "Option<" + type + ">";
    }
    else {
        return type;
    }
};
//# sourceMappingURL=functions.js.map