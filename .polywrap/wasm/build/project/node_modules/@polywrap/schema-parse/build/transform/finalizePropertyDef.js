"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.populatePropertyType = exports.finalizePropertyDef = void 0;
var __1 = require("..");
var finalizePropertyDef = function (abi) {
    return {
        enter: {
            // eslint-disable-next-line @typescript-eslint/naming-convention
            PropertyDefinition: function (def) {
                populatePropertyType(def, abi);
                return def;
            },
        },
    };
};
exports.finalizePropertyDef = finalizePropertyDef;
function populatePropertyType(property, abi) {
    var propertyType;
    if (property.array) {
        populateArrayType(property.array, abi);
        propertyType = property.array;
    }
    else if (property.unresolvedObjectOrEnum) {
        propertyType = resolveObjectOrEnumKind(property, abi);
    }
    else if (property.scalar) {
        propertyType = property.scalar;
    }
    else if (property.object) {
        propertyType = property.object;
    }
    else if (property.enum) {
        propertyType = property.enum;
    }
    else if (property.map) {
        populateMapType(property.map, abi);
        propertyType = property.map;
    }
    else {
        throw Error("Property type is undefined, this should never happen.");
    }
    property.type = propertyType.type;
    property.required = propertyType.required;
}
exports.populatePropertyType = populatePropertyType;
function populateMapType(map, abi) {
    var baseTypeFound = false;
    var currentType = map;
    while (!baseTypeFound) {
        if (currentType.map) {
            currentType = currentType.map;
            populateMapType(currentType, abi);
        }
        else if (currentType.array) {
            currentType = currentType.array;
            populateArrayType(currentType, abi);
        }
        else if (currentType.scalar ||
            currentType.object ||
            currentType.enum ||
            currentType.unresolvedObjectOrEnum) {
            baseTypeFound = true;
        }
        else {
            throw Error("This should never happen, MapDefinition is malformed.\n" + JSON.stringify(map, null, 2));
        }
    }
    if (map.array) {
        map.value = map.array;
    }
    else if (map.unresolvedObjectOrEnum) {
        map.value = resolveObjectOrEnumKind(map, abi);
    }
    else if (map.scalar) {
        map.value = map.scalar;
    }
    else if (map.enum) {
        map.value = map.enum;
    }
    else if (map.map) {
        map.value = map.map;
    }
    else {
        map.value = map.object;
    }
    if (!map.value) {
        throw Error("Map isn't valid.");
    }
}
function populateArrayType(array, abi) {
    var baseTypeFound = false;
    var currentArray = array;
    while (!baseTypeFound) {
        if (currentArray.array) {
            currentArray = currentArray.array;
            populateArrayType(currentArray, abi);
        }
        else if (currentArray.scalar ||
            currentArray.object ||
            currentArray.enum ||
            currentArray.unresolvedObjectOrEnum) {
            baseTypeFound = true;
        }
        else {
            throw Error("This should never happen, ArrayDefinition is malformed.\n" + JSON.stringify(array, null, 2));
        }
    }
    if (array.array) {
        array.item = array.array;
    }
    else if (array.unresolvedObjectOrEnum) {
        array.item = resolveObjectOrEnumKind(array, abi);
    }
    else if (array.scalar) {
        array.item = array.scalar;
    }
    else if (array.enum) {
        array.item = array.enum;
    }
    else if (array.map) {
        array.item = array.map;
    }
    else {
        array.item = array.object;
    }
    if (!array.item) {
        throw Error("Array isn't valid.");
    }
    array.type = "[" + array.item.type + "]";
}
function resolveObjectOrEnumKind(property, abi) {
    var _a, _b;
    if (!property.unresolvedObjectOrEnum) {
        throw Error("Type reference is undefined, this should never happen.");
    }
    var unresolved = property.unresolvedObjectOrEnum;
    // Check to see if the type is a part of the custom types defined inside the schema (objects, enums, envs)
    var customType = abi.objectTypes &&
        abi.objectTypes.find(function (type) { return type.type === unresolved.type; });
    customType = customType
        ? customType
        : abi.importedObjectTypes &&
            abi.importedObjectTypes.find(function (type) { return type.type === unresolved.type; });
    var envType = abi.envType;
    customType = customType
        ? customType
        : (envType === null || envType === void 0 ? void 0 : envType.type) === unresolved.type
            ? envType
            : undefined;
    customType = customType
        ? customType
        : abi.importedEnvTypes &&
            abi.importedEnvTypes.find(function (type) { return type.type === unresolved.type; });
    if (!customType) {
        customType =
            abi.enumTypes &&
                abi.enumTypes.find(function (type) { return type.type === unresolved.type; });
        customType = customType
            ? customType
            : abi.importedEnumTypes &&
                abi.importedEnumTypes.find(function (type) { return type.type === unresolved.type; });
        if (!customType) {
            throw new Error("Unsupported type " + unresolved.type);
        }
        property.enum = __1.createEnumRef({
            name: unresolved.name,
            required: (_a = unresolved.required) !== null && _a !== void 0 ? _a : undefined,
            type: unresolved.type,
        });
        property.unresolvedObjectOrEnum = undefined;
        return property.enum;
    }
    else {
        property.object = __1.createObjectRef({
            name: property.unresolvedObjectOrEnum.name,
            required: (_b = property.unresolvedObjectOrEnum.required) !== null && _b !== void 0 ? _b : undefined,
            type: property.unresolvedObjectOrEnum.type,
        });
        property.unresolvedObjectOrEnum = undefined;
        return property.object;
    }
}
//# sourceMappingURL=finalizePropertyDef.js.map