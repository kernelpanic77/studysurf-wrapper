"use strict";
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.moduleCapabilities = void 0;
function moduleCapabilities() {
    var capabilities = [];
    var enabledInterfaces = new Set();
    return {
        enter: {
            InterfaceDefinition: function (def) {
                for (var type in def.capabilities) {
                    var info = def.capabilities[type];
                    if (info === null || info === void 0 ? void 0 : info.enabled) {
                        capabilities.push({
                            uri: def.uri,
                            namespace: def.namespace,
                            type: type,
                        });
                        enabledInterfaces.add(def.namespace);
                    }
                }
                return def;
            },
        },
        leave: {
            Abi: function (info) {
                var e_1, _a;
                if (info.moduleType) {
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    info.moduleType.capabilities = capabilities;
                }
                if (info.importedModuleTypes) {
                    try {
                        for (var _b = __values(info.importedModuleTypes), _c = _b.next(); !_c.done; _c = _b.next()) {
                            var importedModuleDef = _c.value;
                            if (enabledInterfaces.has(importedModuleDef.namespace)) {
                                importedModuleDef.isInterface = true;
                            }
                        }
                    }
                    catch (e_1_1) { e_1 = { error: e_1_1 }; }
                    finally {
                        try {
                            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                        }
                        finally { if (e_1) throw e_1.error; }
                    }
                }
                return info;
            },
        },
    };
}
exports.moduleCapabilities = moduleCapabilities;
//# sourceMappingURL=moduleCapabilities.js.map