"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getImportedDirectiveValidator = exports.getImportsDirectiveValidator = exports.getEnvDirectiveValidator = exports.getSupportedDirectivesValidator = void 0;
var __1 = require("..");
var getSupportedDirectivesValidator = function () {
    var supportedDirectives = [
        "imported",
        "imports",
        "capability",
        "enabled_interface",
        "annotate",
        "env",
    ];
    var unsupportedUsages = [];
    return {
        visitor: {
            enter: {
                Directive: function (node) {
                    var name = node.name.value;
                    if (!supportedDirectives.includes(name)) {
                        unsupportedUsages.push(name);
                    }
                },
            },
        },
        cleanup: function () {
            if (unsupportedUsages.length) {
                throw new Error("Found the following usages of unsupported directives:" + unsupportedUsages.map(function (u) { return "\n@" + u; }));
            }
        },
    };
};
exports.getSupportedDirectivesValidator = getSupportedDirectivesValidator;
var getEnvDirectiveValidator = function () {
    var currentType;
    return {
        visitor: {
            enter: {
                ObjectTypeDefinition: function (node) {
                    currentType = node.name.value;
                },
                FieldDefinition: function (node) {
                    var _a;
                    var envDirective = (_a = node.directives) === null || _a === void 0 ? void 0 : _a.find(function (d) { return d.name.value === "env"; });
                    if (envDirective &&
                        currentType &&
                        !__1.isModuleType(currentType) &&
                        !__1.isImportedModuleType(currentType)) {
                        throw new Error("@env directive should only be used on Module method definitions. Found on field '" + node.name.value + "' of type '" + currentType + "'");
                    }
                },
            },
            leave: {
                ObjectTypeDefinition: function () {
                    currentType = undefined;
                },
            },
        },
    };
};
exports.getEnvDirectiveValidator = getEnvDirectiveValidator;
var getImportsDirectiveValidator = function () {
    var isInsideObjectTypeDefinition = false;
    var ObjectTypeDefinition = function (node) {
        isInsideObjectTypeDefinition = true;
        var badUsageLocations = [];
        var importsAllowedObjectTypes = ["Module"];
        var directives = node.directives &&
            node.directives.map(function (directive) { return directive.name.value; });
        if (directives &&
            directives.includes("imports") &&
            !importsAllowedObjectTypes.includes(node.name.value)) {
            badUsageLocations.push(node.name.value);
        }
        if (badUsageLocations.length) {
            throw new Error("@imports directive should only be used on Module type definitions, " +
                ("but it is being used on the following ObjectTypeDefinitions:" + badUsageLocations.map(function (b) { return "\n" + b; })));
        }
    };
    var Directive = function (node, key, parent, path) {
        if (node.name.value !== "imports") {
            return;
        }
        if (!isInsideObjectTypeDefinition) {
            throw new Error("@imports directive should only be used on Module type definitions, " +
                ("but it is being used in the following location: " + path.join(" -> ")));
        }
        var args = node.arguments || [];
        var typesArgument = args.find(function (arg) { return arg.name.value === "types"; });
        if (!args.length || !typesArgument) {
            throw new Error("@imports directive requires argument 'types' of type [String!]!");
        }
        if (args.length > 1) {
            throw new Error("@imports directive takes only one argument 'types', but found: " + args
                .filter(function (arg) { return arg.name.value !== "types"; })
                .map(function (arg) { return "\n- " + arg.name.value; }));
        }
        if (typesArgument.value.kind === "ListValue") {
            var values = typesArgument.value.values;
            if (!values.length) {
                throw new Error("@imports directive's 'types' argument of type [String!]! requires at least one value");
            }
            var nonStringValues = values.filter(function (value) { return value.kind !== "StringValue"; });
            if (nonStringValues.length) {
                throw new Error("@imports directive's 'types' List values must be of type String, but found: \n" + nonStringValues.map(function (nonStringValue) { return "\n -" + nonStringValue.kind; }));
            }
        }
    };
    return {
        visitor: {
            enter: function (node, key, parent, path) {
                if (node.kind === "ObjectTypeDefinition") {
                    ObjectTypeDefinition(node);
                }
                else if (node.kind === "Directive") {
                    Directive(node, key, parent, path);
                }
                else if (node.kind !== "NamedType" &&
                    node.kind !== "Name" &&
                    node.kind !== "StringValue") {
                    isInsideObjectTypeDefinition = false;
                }
            },
        },
    };
};
exports.getImportsDirectiveValidator = getImportsDirectiveValidator;
var getImportedDirectiveValidator = function () {
    var isInsideObjectOrEnumTypeDefinition = false;
    var Directive = function (node, key, parent, path) {
        if (node.name.value !== "imported") {
            return;
        }
        if (!isInsideObjectOrEnumTypeDefinition) {
            throw new Error("@imported directive should only be used on object or enum type definitions, " +
                ("but it is being used in the following location: " + path.join(" -> ")));
        }
        var imported = {
            uri: "",
            namespace: "",
            nativeType: "",
        };
        var args = node.arguments || [];
        var expectedArguments = Object.keys(imported);
        var actualArguments = args.map(function (arg) { return arg.name.value; });
        var missingArguments = expectedArguments.filter(function (expected) { return !actualArguments.includes(expected); });
        if (missingArguments.length) {
            throw new Error("@imported directive is missing the following arguments:" + missingArguments.map(function (arg) { return "\n- " + arg; }));
        }
        var extraArguments = actualArguments.filter(function (actual) { return !expectedArguments.includes(actual); });
        if (extraArguments.length) {
            throw new Error("@imported directive takes only 3 arguments: " + expectedArguments.join(", ") + ". But found:" + extraArguments.map(function (arg) { return "\n- " + arg; }));
        }
    };
    return {
        visitor: {
            enter: function (node, key, parent, path) {
                if (node.kind === "Directive") {
                    Directive(node, key, parent, path);
                }
                else if (node.kind === "ObjectTypeDefinition" ||
                    node.kind === "EnumTypeDefinition") {
                    isInsideObjectOrEnumTypeDefinition = true;
                }
                else if (node.kind !== "NamedType" &&
                    node.kind !== "Name" &&
                    node.kind !== "StringValue") {
                    isInsideObjectOrEnumTypeDefinition = false;
                }
            },
        },
    };
};
exports.getImportedDirectiveValidator = getImportedDirectiveValidator;
//# sourceMappingURL=directives.js.map