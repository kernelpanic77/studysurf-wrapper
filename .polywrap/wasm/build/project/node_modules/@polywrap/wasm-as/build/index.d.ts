type i8 = number;
type i16 = number;
type i32 = number;
type i64 = bigint;
type isize = number;
type u8 = number;
type u16 = number;
type u32 = number;
type u64 = bigint;
type usize = number;
type f32 = number;
type f64 = number;
type bool = boolean | number;
export abstract class Read {
  static wrap(ptr: usize): Read;
  valueOf(): usize;
  readBool(): bool;
  readInt8(): i8;
  readInt16(): i16;
  readInt32(): i32;
  readUInt8(): u8;
  readUInt16(): u16;
  readUInt32(): u32;
  readFloat32(): f32;
  readFloat64(): f64;
  readStringLength(): u32;
  readString(): usize;
  readBytesLength(): u32;
  readBytes(): usize;
  readBigInt(): usize;
  readBigNumber(): usize;
  readJSON(): usize;
  readArrayLength(): u32;
  readMapLength(): u32;
  readOptionalBool(): usize;
  readOptionalInt8(): usize;
  readOptionalInt16(): usize;
  readOptionalInt32(): usize;
  readOptionalUInt8(): usize;
  readOptionalUInt16(): usize;
  readOptionalUInt32(): usize;
  readOptionalFloat32(): usize;
  readOptionalFloat64(): usize;
  readOptionalString(): usize;
  readOptionalBytes(): usize;
  readOptionalBigInt(): usize;
  readOptionalBigNumber(): usize;
  readOptionalJSON(): usize;
  isNextNil(): bool;
  isNextString(): bool;
  context(): usize;
  constructor();
}
export class ReadDecoder extends Read {
  static wrap(ptr: usize): ReadDecoder;
  valueOf(): usize;
  readBool(): bool;
  readInt8(): i8;
  readInt16(): i16;
  readInt32(): i32;
  readUInt8(): u8;
  readUInt16(): u16;
  readUInt32(): u32;
  readFloat32(): f32;
  readFloat64(): f64;
  readStringLength(): u32;
  readString(): usize;
  readBytesLength(): u32;
  readBytes(): usize;
  readBigInt(): usize;
  readBigNumber(): usize;
  readJSON(): usize;
  readArrayLength(): u32;
  readArray(fn: usize): usize;
  readMapLength(): u32;
  readOptionalBool(): usize;
  readOptionalInt8(): usize;
  readOptionalInt16(): usize;
  readOptionalInt32(): usize;
  readOptionalUInt8(): usize;
  readOptionalUInt16(): usize;
  readOptionalUInt32(): usize;
  readOptionalFloat32(): usize;
  readOptionalFloat64(): usize;
  readOptionalString(): usize;
  readOptionalBytes(): usize;
  readOptionalBigInt(): usize;
  readOptionalBigNumber(): usize;
  readOptionalJSON(): usize;
  isNextNil(): bool;
  isNextString(): bool;
  context(): usize;
  constructor(ua: usize, context?: usize);
}
export abstract class Write {
  static wrap(ptr: usize): Write;
  valueOf(): usize;
  writeNil(): void;
  writeBool(value: bool): void;
  writeInt8(value: i8): void;
  writeInt16(value: i16): void;
  writeInt32(value: i32): void;
  writeUInt8(value: u8): void;
  writeUInt16(value: u16): void;
  writeUInt32(value: u32): void;
  writeFloat32(value: f32): void;
  writeFloat64(value: f64): void;
  writeStringLength(length: u32): void;
  writeString(value: usize): void;
  writeBytesLength(length: u32): void;
  writeBytes(value: usize): void;
  writeBigInt(value: usize): void;
  writeBigNumber(value: usize): void;
  writeJSON(value: usize): void;
  writeArrayLength(length: u32): void;
  writeMapLength(length: u32): void;
  writeOptionalBool(value: usize): void;
  writeOptionalInt8(value: usize): void;
  writeOptionalInt16(value: usize): void;
  writeOptionalInt32(value: usize): void;
  writeOptionalUInt8(value: usize): void;
  writeOptionalUInt16(value: usize): void;
  writeOptionalUInt32(value: usize): void;
  writeOptionalFloat32(value: usize): void;
  writeOptionalFloat64(value: usize): void;
  writeOptionalString(value: usize): void;
  writeOptionalBytes(value: usize): void;
  writeOptionalBigInt(value: usize): void;
  writeOptionalBigNumber(value: usize): void;
  writeOptionalJSON(value: usize): void;
  context(): usize;
  constructor();
}
export class WriteEncoder extends Write {
  static wrap(ptr: usize): WriteEncoder;
  valueOf(): usize;
  writeNil(): void;
  writeBool(value: bool): void;
  writeInt8(value: i8): void;
  writeInt16(value: i16): void;
  writeInt32(value: i32): void;
  writeUInt8(value: u8): void;
  writeUInt16(value: u16): void;
  writeUInt32(value: u32): void;
  writeFloat32(value: f32): void;
  writeFloat64(value: f64): void;
  writeStringLength(length: u32): void;
  writeString(value: usize): void;
  writeBytesLength(length: u32): void;
  writeBytes(value: usize): void;
  writeBigInt(value: usize): void;
  writeBigNumber(value: usize): void;
  writeJSON(value: usize): void;
  writeArrayLength(length: u32): void;
  writeMapLength(length: u32): void;
  writeOptionalBool(value: usize): void;
  writeOptionalInt8(value: usize): void;
  writeOptionalInt16(value: usize): void;
  writeOptionalInt32(value: usize): void;
  writeOptionalUInt8(value: usize): void;
  writeOptionalUInt16(value: usize): void;
  writeOptionalUInt32(value: usize): void;
  writeOptionalFloat32(value: usize): void;
  writeOptionalFloat64(value: usize): void;
  writeOptionalString(value: usize): void;
  writeOptionalBytes(value: usize): void;
  writeOptionalBigInt(value: usize): void;
  writeOptionalBigNumber(value: usize): void;
  writeOptionalJSON(value: usize): void;
  context(): usize;
  constructor(ua: usize, sizer: usize, context?: usize);
}
export class WriteSizer extends Write {
  static wrap(ptr: usize): WriteSizer;
  valueOf(): usize;
  writeNil(): void;
  writeBool(_value: bool): void;
  writeInt8(value: i8): void;
  writeInt16(value: i16): void;
  writeInt32(value: i32): void;
  writeUInt8(value: u8): void;
  writeUInt16(value: u16): void;
  writeUInt32(value: u32): void;
  writeFloat32(_value: f32): void;
  writeFloat64(_value: f64): void;
  writeStringLength(length: u32): void;
  writeString(value: usize): void;
  writeBytesLength(length: u32): void;
  writeBytes(value: usize): void;
  writeBigInt(value: usize): void;
  writeBigNumber(value: usize): void;
  writeJSON(value: usize): void;
  writeArrayLength(length: u32): void;
  writeMapLength(length: u32): void;
  writeOptionalBool(value: usize): void;
  writeOptionalInt8(value: usize): void;
  writeOptionalInt16(value: usize): void;
  writeOptionalInt32(value: usize): void;
  writeOptionalUInt8(value: usize): void;
  writeOptionalUInt16(value: usize): void;
  writeOptionalUInt32(value: usize): void;
  writeOptionalFloat32(value: usize): void;
  writeOptionalFloat64(value: usize): void;
  writeOptionalString(value: usize): void;
  writeOptionalBytes(value: usize): void;
  writeOptionalBigInt(value: usize): void;
  writeOptionalBigNumber(value: usize): void;
  writeOptionalJSON(value: usize): void;
  context(): usize;
  constructor(context?: usize);
  length: i32;
  extByteLengths: usize;
}
export namespace JSON {
  export abstract class Value {
    static wrap(ptr: usize): Value;
    valueOf(): usize;
    static String(str: usize): usize;
    static Number(num: f64): usize;
    static Float(num: f64): usize;
    static Integer(num: i64): usize;
    static Bool(b: bool): usize;
    static Null(): usize;
    static Array(): usize;
    static Object(): usize;
    get isString(): bool;
    get isNum(): bool;
    get isFloat(): bool;
    get isInteger(): bool;
    get isBool(): bool;
    get isNull(): bool;
    get isArr(): bool;
    get isObj(): bool;
    stringify(): usize;
    toString(): usize;
    constructor();
  }
  export class Str extends Value {
    static wrap(ptr: usize): Str;
    valueOf(): usize;
    stringify(): usize;
    toString(): usize;
    constructor(_str: usize);
    _str: usize;
    valueOf(): usize;
  }
  export class Num extends Value {
    static wrap(ptr: usize): Num;
    valueOf(): usize;
    stringify(): usize;
    constructor(_num: f64);
    _num: f64;
    valueOf(): f64;
  }
  export class Float extends Num {
    static wrap(ptr: usize): Float;
    valueOf(): usize;
    constructor(_num: f64);
  }
  export class Integer extends Value {
    static wrap(ptr: usize): Integer;
    valueOf(): usize;
    stringify(): usize;
    constructor(_num: i64);
    _num: i64;
    valueOf(): i64;
  }
  export class Null extends Value {
    static wrap(ptr: usize): Null;
    valueOf(): usize;
    stringify(): usize;
    constructor();
  }
  export class Bool extends Value {
    static wrap(ptr: usize): Bool;
    valueOf(): usize;
    stringify(): usize;
    constructor(_bool: bool);
    _bool: bool;
    valueOf(): bool;
  }
  export class Arr extends Value {
    static wrap(ptr: usize): Arr;
    valueOf(): usize;
    stringify(): usize;
    constructor();
    _arr: usize;
    push(obj: usize): void;
    valueOf(): usize;
  }
  export class Obj extends Value {
    static wrap(ptr: usize): Obj;
    valueOf(): usize;
    stringify(): usize;
    _obj: usize;
    constructor();
    get keys(): usize;
    valueOf(): usize;
    set(key: usize, value: usize): void;
    has(key: usize): bool;
    get(key: usize): usize;
    getValue(key: usize): usize;
    getString(key: usize): usize;
    getNum(key: usize): usize;
    getFloat(key: usize): usize;
    getInteger(key: usize): usize;
    getBool(key: usize): usize;
    getArr(key: usize): usize;
    getObj(key: usize): usize;
  }
}
export abstract class JSONHandler {
  static wrap(ptr: usize): JSONHandler;
  valueOf(): usize;
  setString(name: usize, value: usize): void;
  setBoolean(name: usize, value: bool): void;
  setNull(name: usize): void;
  setInteger(name: usize, value: i64): void;
  setFloat(name: usize, value: f64): void;
  pushArray(name: usize): bool;
  popArray(): void;
  pushObject(name: usize): bool;
  popObject(): void;
  constructor();
}
export class ThrowingJSONHandler extends JSONHandler {
  static wrap(ptr: usize): ThrowingJSONHandler;
  valueOf(): usize;
  setString(name: usize, value: usize): void;
  setBoolean(name: usize, value: bool): void;
  setNull(name: usize): void;
  setInteger(name: usize, value: i64): void;
  setFloat(name: usize, value: f64): void;
  pushArray(name: usize): bool;
  pushObject(name: usize): bool;
  constructor();
}
export class DecoderState {
  static wrap(ptr: usize): DecoderState;
  valueOf(): usize;
  lastKey: usize;
  readIndex: i32;
  buffer: usize;
  constructor(buffer: usize);
  get ptr(): usize;
  readString(start: usize, end?: usize): usize;
}
export class JSONEncoder {
  static wrap(ptr: usize): JSONEncoder;
  valueOf(): usize;
  constructor();
  get isFirstKey(): bool;
  serialize(): usize;
  toString(): usize;
  setString(name: usize, value: usize): void;
  setBoolean(name: usize, value: bool): void;
  setNull(name: usize): void;
  setInteger(name: usize, value: i64): void;
  setFloat(name: usize, value: f64): void;
  pushArray(name: usize): bool;
  popArray(): void;
  pushObject(name: usize): bool;
  popObject(): void;
}
export class BigInt {
  static wrap(ptr: usize): BigInt;
  valueOf(): usize;
  static from(val: usize): usize;
  static fromString(bigInteger: usize, radix?: i32): usize;
  static fromUInt16(val: u16): usize;
  static fromUInt32(val: u32): usize;
  static fromUInt64(val: u64): usize;
  static fromInt16(val: i16): usize;
  static fromInt32(val: i32): usize;
  static fromInt64(val: i64): usize;
  static get ZERO(): usize;
  static get ONE(): usize;
  static get NEG_ONE(): usize;
  static divOp(left: usize, right: usize): usize;
  get isNegative(): bool;
  copy(): usize;
  opposite(): usize;
  abs(): usize;
  toString(radix?: i32): usize;
  toInt32(): i32;
  toInt64(): i64;
  toUInt32(): u32;
  toUInt64(): u64;
  eq(other: usize): bool;
  ne(other: usize): bool;
  lt(other: usize): bool;
  lte(other: usize): bool;
  gt(other: usize): bool;
  gte(other: usize): bool;
  compareTo(other: usize): i32;
  magCompareTo(other: usize): i32;
  add(other: usize): usize;
  sub(other: usize): usize;
  mul2(): usize;
  div2(): usize;
  mulPowTwo(k: i32): usize;
  divPowTwo(k: i32): usize;
  modPowTwo(k: i32): usize;
  leftShift(k: i32): usize;
  rightShift(k: i32): usize;
  mul(other: usize): usize;
  pow(k: i32): usize;
  square(): usize;
  sqrt(): usize;
  div(other: usize): usize;
  mod(other: usize): usize;
  divMod(other: usize): usize;
  addInt(b: u32): usize;
  subInt(b: u32): usize;
  mulInt(b: u32): usize;
  divInt(b: u32): usize;
  modInt(b: u32): u32;
  divModInt(b: u32): usize;
  roundedDivInt(b: u32): usize;
  bitwiseNot(): usize;
  bitwiseAnd(other: usize): usize;
  bitwiseOr(other: usize): usize;
  bitwiseXor(other: usize): usize;
  countBits(): i32;
  isOdd(): bool;
  isZero(): bool;
}
export class BigNumber {
  static wrap(ptr: usize): BigNumber;
  valueOf(): usize;
  static DEFAULT_PRECISION: i32;
  static DEFAULT_ROUNDING: i32;
  static MAX_POWER: i32;
  static ONE: usize;
  static HALF: usize;
  static from(val: usize): usize;
  static from(val: i32): usize;
  static fromString(val: usize, precision?: i32, rounding?: i32): usize;
  static fromBigInt(val: usize): usize;
  static fromFloat64(val: f64, precision?: i32, rounding?: i32): usize;
  readonly m: usize;
  readonly e: i32;
  get precision(): i32;
  get isInteger(): bool;
  constructor(m: usize, e: i32, precision: i32);
  copy(): usize;
  opposite(): usize;
  abs(): usize;
  reciprocal(precision?: i32, rounding?: i32): usize;
  toString(): usize;
  toFixed(places?: i32, rounding?: i32): usize;
  toSignificant(digits?: i32, rounding?: i32): usize;
  toBigInt(): usize;
  toFloat64(): f64;
  eq(other: usize): bool;
  ne(other: usize): bool;
  lt(other: usize): bool;
  lte(other: usize): bool;
  gt(other: usize): bool;
  gte(other: usize): bool;
  compareTo(other: usize): i32;
  magCompareTo(other: usize): i32;
  add(other: usize, precision?: i32, rounding?: i32): usize;
  sub(other: usize, precision?: i32, rounding?: i32): usize;
  sub(other: i32, precision?: i32, rounding?: i32): usize;
  mul(other: usize, precision?: i32, rounding?: i32): usize;
  square(precision?: i32, rounding?: i32): usize;
  div(other: usize, precision?: i32, rounding?: i32): usize;
  sqrt(precision?: i32, rounding?: i32): usize;
  pow(k: i32, precision?: i32, rounding?: i32): usize;
  get isNegative(): bool;
  isZero(): bool;
  floor(): usize;
  ceil(): usize;
  setScale(e: i32, rounding?: i32): usize;
  round(precision?: i32, rounding?: i32): usize;
}
export enum Rounding {
  UP,
  DOWN,
  CEIL,
  FLOOR,
  HALF_UP,
  HALF_DOWN,
  HALF_EVEN,
  NONE,
}
export class Context {
  static wrap(ptr: usize): Context;
  valueOf(): usize;
  constructor(description?: usize);
  isEmpty(): bool;
  get length(): i32;
  push(item: usize, type?: usize, info?: usize): void;
  pop(): usize;
  toString(): usize;
  printWithContext(message: usize): usize;
}
export function __wrap_debug_log(ptr: u32, len: u32): void;
export function wrap_debug_log(msg: usize): void;
export function __wrap_abort(msg_ptr: u32, msg_len: u32, file_ptr: u32, file_len: u32, line: u32, column: u32): void;
export function wrap_abort(msg: usize, file: usize, line: u32, column: u32): void;
export function __wrap_invoke_args(method_ptr: u32, args_ptr: u32): void;
export function __wrap_invoke_result(ptr: u32, len: u32): void;
export function __wrap_invoke_error(ptr: u32, len: u32): void;
export class InvokeArgs {
  static wrap(ptr: usize): InvokeArgs;
  valueOf(): usize;
  method: usize;
  args: usize;
  constructor(method: usize, args: usize);
}
export function wrap_invoke_args(method_size: u32, args_size: u32): usize;
export function wrap_invoke(args: usize, env_size: u32, fn: usize): bool;
export function __wrap_subinvoke(uri_ptr: u32, uri_len: u32, method_ptr: u32, method_len: u32, args_ptr: u32, args_len: u32): bool;
export function __wrap_subinvoke_result_len(): u32;
export function __wrap_subinvoke_result(ptr: u32): void;
export function __wrap_subinvoke_error_len(): u32;
export function __wrap_subinvoke_error(ptr: u32): void;
export function wrap_subinvoke(uri: usize, method: usize, args: usize): usize;
export function __wrap_subinvokeImplementation(interface_uri_ptr: u32, interface_uri_len: u32, impl_uri_ptr: u32, impl_uri_len: u32, method_ptr: u32, method_len: u32, args_ptr: u32, args_len: u32): bool;
export function __wrap_subinvokeImplementation_result_len(): u32;
export function __wrap_subinvokeImplementation_result(ptr: u32): void;
export function __wrap_subinvokeImplementation_error_len(): u32;
export function __wrap_subinvokeImplementation_error(ptr: u32): void;
export function wrap_subinvokeImplementation(interfaceUri: usize, implUri: usize, method: usize, args: usize): usize;
export function __wrap_load_env(enviroment_ptr: u32): void;
export function wrap_load_env(env_size: u32): usize;
export function __wrap_getImplementations(uri_ptr: u32, uri_len: u32): bool;
export function __wrap_getImplementations_result_len(): u32;
export function __wrap_getImplementations_result(ptr: u32): void;
export function wrap_getImplementations(uri: usize): usize;
export const memory: WebAssembly.Memory;
export const __setArgumentsLength: ((n: i32) => void) | undefined;
