export abstract class AbstractInt<T> {
    protected _value: T;

    constructor(value: T = 0, byteLength: i32 = 0) {
        this._value = value;
    }

    @inline
    unwrap(): T {
        return this._value;
    }

    /** Encodes the value as u8[] as per the SCALE codec specification */
    toU8a(): u8[] {
        let bytesEncoded = new Array<u8>(8);
        // Bytes.putUint<T>(bytesEncoded, this.unwrap(), this._byteLength);
        return bytesEncoded;
    }

    populateFromBytes(bytes: u8[], index: i32 = 0): i32 {
        assert(bytes.length - index > 0, "AbstractInt: Invalid bytes provided");
        // this._value = Bytes.toUint<T>(bytes, this._byteLength, index);
        return this.encodedLength() + index;
    }
    

    get _byteLength(): i32 {
        return 0;


        
    }

    /**
     * @description The length of Uint8Array when the value is encoded
     */
    @inline
    encodedLength(): i32 {
        return this._byteLength;
    }
}


export class UInt8 extends AbstractInt<u8> {
    @inline
    get _byteLength(): i32 {
        return 1;
    }

    constructor(value: u8 = 0) {
        super(value, 0);
    }

    /**
     * @description Instantiates new UInt8 from u8[] SCALE encoded bytes
     * NOTE: if the length of the provided value is less than the byte length of the UInt8,
     * it is filled with 0 bytes
     */
    // static fromU8a(value: u8[], index: i32 = 0): UInt8 {
    //     assert(
    //         value.length - index > 0,
    //         "Uint8: cannot decode invalid u8 encoded value"
    //     );
    //     return new UInt8(value[index]);
    // }
}

export class Int8 extends AbstractInt<i8> {
    @inline
    get _byteLength(): i32 {
        return 1;
    }

    constructor(value: i8 = 0) {
        super(value);
    }

    // /**
    //  * @description Instantiates new Int8 from u8[] SCALE encoded bytes
    //  * NOTE: if the length of the provided value is less than the byte length of the Int8,
    //  * it is filled with 0 bytes
    //  * */
    // static fromU8a(value: u8[], index: i32 = 0): Int8 {
    //     assert(value.length - index > 0, "Int8: empty bytes array provided");
    //     return new Int8(value[index]);
    // }
}



describe("Abs", () => {
    it("from, new", () => {
        let n = instantiate<UInt8>();
        let n2 = instantiate<AbstractInt<u8>>();
        n.encodedLength();
        n.unwrap();
        n.populateFromBytes(new Array<u8>(8));
        expect(n.unwrap()).toStrictEqual(n2.unwrap());
    });
});



// describe("UInt8", () => {
//     it("should encode uint8", () => {
//         let v1 = new UInt8(1);
//         expect<u8[]>(v1.toU8a()).toStrictEqual([0x01]);
//         expect<i32>(v1.encodedLength()).toStrictEqual(1);

//         let v2 = new UInt8(15);
//         expect<u8[]>(v2.toU8a()).toStrictEqual([0xf]);
//         expect<i32>(v2.encodedLength()).toStrictEqual(1);

//         let v3 = new UInt8(16);
//         expect<u8[]>(v3.toU8a()).toStrictEqual([0x10]);
//         expect<i32>(v3.encodedLength()).toStrictEqual(1);

//         let v4 = new UInt8(127);
//         expect<u8[]>(v4.toU8a()).toStrictEqual([0x7f]);
//         expect<i32>(v4.encodedLength()).toStrictEqual(1);

//         let v5 = new UInt8(255);
//         expect<u8[]>(v5.toU8a()).toStrictEqual([0xff]);
//         expect<i32>(v5.encodedLength()).toStrictEqual(1);

//         let v6 = new UInt8(241);
//         expect<u8[]>(v6.toU8a()).toStrictEqual([0xf1]);
//         expect<i32>(v6.encodedLength()).toStrictEqual(1);

//         let v7 = new UInt8(129);
//         expect<u8[]>(v7.toU8a()).toStrictEqual([0x81]);
//         expect<i32>(v7.encodedLength()).toStrictEqual(1);
//     });

//     it("should decode uint8", () => {
//         expect<UInt8>(UInt8.fromU8a([0x01])).toStrictEqual(new UInt8(1));
//         expect<UInt8>(UInt8.fromU8a([0xf])).toStrictEqual(new UInt8(15));
//         expect<UInt8>(UInt8.fromU8a([0x10])).toStrictEqual(new UInt8(16));
//         expect<UInt8>(UInt8.fromU8a([0xf1])).toStrictEqual(new UInt8(241));
//         expect<UInt8>(UInt8.fromU8a([0x81])).toStrictEqual(new UInt8(129));
//     });

//     it("should decode uint8 with populate method", () => {
//         const uInt8 = new UInt8();
//         uInt8.populateFromBytes([0x7f]);
//         expect<UInt8>(uInt8).toStrictEqual(new UInt8(127));
//         uInt8.populateFromBytes([0xff]);
//         expect<UInt8>(uInt8).toStrictEqual(new UInt8(255));
//         uInt8.populateFromBytes([1]);
//         expect<UInt8>(uInt8).toStrictEqual(new UInt8(1));
//         uInt8.populateFromBytes([69]);
//         expect<UInt8>(uInt8).toStrictEqual(new UInt8(69));
//     });

//     it("should decode only first byte", () => {
//         expect<UInt8>(UInt8.fromU8a([0x05, 0])).toStrictEqual(new UInt8(5));
//         expect<UInt8>(UInt8.fromU8a([0x01, 0, 1, 2, 12])).toStrictEqual(
//             new UInt8(1)
//         );
//     });

//     itThrows("should throw when empty array is provided", () => {
//         let v1 = UInt8.fromU8a([]);
//     });
//     itThrows("should throw when index is out of range", () => {
//         let v1 = UInt8.fromU8a([1], 2);
//     });
// });


// describe("Int8", () => {
//     it("should encode int8", () => {
//         let v1 = new Int8(1);
//         expect<u8[]>(v1.toU8a()).toStrictEqual([0x01]);
//         expect<i32>(v1.encodedLength()).toStrictEqual(1);

//         let v2 = new Int8(15);
//         expect<u8[]>(v2.toU8a()).toStrictEqual([0xf]);
//         expect<i32>(v2.encodedLength()).toStrictEqual(1);

//         let v3 = new Int8(16);
//         expect<u8[]>(v3.toU8a()).toStrictEqual([0x10]);
//         expect<i32>(v3.encodedLength()).toStrictEqual(1);

//         let v4 = new Int8(127);
//         expect<u8[]>(v4.toU8a()).toStrictEqual([0x7f]);
//         expect<i32>(v4.encodedLength()).toStrictEqual(1);

//         let v5 = new Int8(-1);
//         expect<u8[]>(v5.toU8a()).toStrictEqual([0xff]);
//         expect<i32>(v5.encodedLength()).toStrictEqual(1);

//         let v6 = new Int8(-15);
//         expect<u8[]>(v6.toU8a()).toStrictEqual([0xf1]);
//         expect<i32>(v6.encodedLength()).toStrictEqual(1);

//         let v7 = new Int8(-127);
//         expect<u8[]>(v7.toU8a()).toStrictEqual([0x81]);
//         expect<i32>(v7.encodedLength()).toStrictEqual(1);
//     });

//     it("should decode int8", () => {
//         expect<Int8>(Int8.fromU8a([0x01])).toStrictEqual(new Int8(1));
//         expect<Int8>(Int8.fromU8a([0xf])).toStrictEqual(new Int8(15));
//         expect<Int8>(Int8.fromU8a([0x10])).toStrictEqual(new Int8(16));
//         expect<Int8>(Int8.fromU8a([0xf1])).toStrictEqual(new Int8(-15));
//     });
//     it("should decode using populate method", () => {
//         const int8 = new Int8();
//         const one = new Int8(1);
//         int8.populateFromBytes([0x7f]);
//         expect<Int8>(int8).toStrictEqual(new Int8(127));
//         expect((int8 - one).unwrap()).toBe(126);
//         expect((int8 + one).unwrap()).toBe(-128);
//         expect((int8 + one + one).unwrap()).toBe(-127);
//         int8.populateFromBytes([0xff]);
//         expect<Int8>(int8).toStrictEqual(new Int8(-1));
//         int8.populateFromBytes([0xf1]);
//         expect<Int8>(int8).toStrictEqual(new Int8(-15));
//         int8.populateFromBytes([0x81]);
//         expect<Int8>(int8).toStrictEqual(new Int8(-127));
//     });

//     it("should decode only first byte", () => {
//         expect<Int8>(Int8.fromU8a([0xff, 0])).toStrictEqual(new Int8(-1));
//         expect<Int8>(Int8.fromU8a([0, 0, 1, 0xf1, 12], 3)).toStrictEqual(
//             new Int8(-15)
//         );
//     });

//     itThrows("should throw when empty array is provided", () => {
//         let v1 = Int8.fromU8a([]);
//     });
//     itThrows("should throw when index is out of range", () => {
//         let v1 = Int8.fromU8a([1, 0, 1], 3);
//     });
// });


