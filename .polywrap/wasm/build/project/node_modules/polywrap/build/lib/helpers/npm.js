"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.checkIfOnline = exports.shouldUseYarn = void 0;
var child_process_1 = require("child_process");
var dns_1 = __importDefault(require("dns"));
var url_1 = __importDefault(require("url"));
function shouldUseYarn() {
    try {
        child_process_1.execSync("yarnpkg --version", { stdio: "ignore" });
        return true;
    }
    catch (e) {
        return false;
    }
}
exports.shouldUseYarn = shouldUseYarn;
function getProxy() {
    if (process.env.https_proxy) {
        return process.env.https_proxy;
    }
    else {
        try {
            // Trying to read https-proxy from .npmrc
            var httpsProxy = child_process_1.execSync("npm config get https-proxy")
                .toString()
                .trim();
            return httpsProxy !== "null" ? httpsProxy : undefined;
        }
        catch (e) {
            return undefined;
        }
    }
}
function checkIfOnline(useYarn) {
    if (!useYarn) {
        // Don't ping the Yarn registry.
        // We'll just assume the best case.
        return Promise.resolve(true);
    }
    return new Promise(function (resolve) {
        dns_1.default.lookup("registry.yarnpkg.com", function (err) {
            var proxy;
            if (err != null && (proxy = getProxy())) {
                // If a proxy is defined, we likely can't resolve external hostnames.
                // Try to resolve the proxy name as an indication of a connection.
                dns_1.default.lookup(url_1.default.parse(proxy).hostname || "", function (proxyErr) {
                    resolve(proxyErr == null);
                });
            }
            else {
                resolve(err == null);
            }
        });
    });
}
exports.checkIfOnline = checkIfOnline;
//# sourceMappingURL=npm.js.map