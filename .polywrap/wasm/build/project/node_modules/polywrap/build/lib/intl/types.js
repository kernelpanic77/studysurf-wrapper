"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.intlMsg = void 0;
var utils_1 = require("./utils");
/// NOTE: This is an auto-generated file. See scripts/generateIntlTypes.ts
/* eslint-disable */
var intl = utils_1.getIntl();
exports.intlMsg = {
    commands_common_options_configPath: function () { return intl.formatMessage({ id: "commands_common_options_configPath", defaultMessage: "config-path" }); },
    commands_common_options_config: function () { return intl.formatMessage({ id: "commands_common_options_config", defaultMessage: "Add custom configuration to the PolywrapClient" }); },
    commands_common_options_verbose: function () { return intl.formatMessage({ id: "commands_common_options_verbose", defaultMessage: "Verbose output (default: false)" }); },
    commands_common_options_quiet: function () { return intl.formatMessage({ id: "commands_common_options_quiet", defaultMessage: "Suppress output (default: false)" }); },
    commands_build_description: function () { return intl.formatMessage({ id: "commands_build_description", defaultMessage: "Build Polywrap Projects (type: interface, wasm)" }); },
    commands_build_error_manifestPathMissing: function (options) { return intl.formatMessage({ id: "commands_build_error_manifestPathMissing", defaultMessage: "{option} option missing {argument} argument" }, options); },
    commands_build_error_manifestNotFound: function (options) { return intl.formatMessage({ id: "commands_build_error_manifestNotFound", defaultMessage: "Manifest not found. Search paths used: {paths}" }, options); },
    commands_build_error_outputDirMissingPath: function (options) { return intl.formatMessage({ id: "commands_build_error_outputDirMissingPath", defaultMessage: "{option} option missing {argument} argument" }, options); },
    commands_build_keypressListener_exit: function () { return intl.formatMessage({ id: "commands_build_keypressListener_exit", defaultMessage: "Exit: [CTRL + C], [ESC], or [Q]" }); },
    commands_build_keypressListener_watching: function () { return intl.formatMessage({ id: "commands_build_keypressListener_watching", defaultMessage: "Watching" }); },
    commands_build_options_h: function () { return intl.formatMessage({ id: "commands_build_options_h", defaultMessage: "Show usage information" }); },
    commands_build_options_m: function (options) { return intl.formatMessage({ id: "commands_build_options_m", defaultMessage: "Path to the Polywrap Build manifest file (default: {default})" }, options); },
    commands_build_options_o: function (options) { return intl.formatMessage({ id: "commands_build_options_o", defaultMessage: "Output directory for build results (default: {default})" }, options); },
    commands_build_options_o_path: function () { return intl.formatMessage({ id: "commands_build_options_o_path", defaultMessage: "path" }); },
    commands_build_options_options: function () { return intl.formatMessage({ id: "commands_build_options_options", defaultMessage: "options" }); },
    commands_build_options_t: function () { return intl.formatMessage({ id: "commands_build_options_t", defaultMessage: "Use the development server's ENS instance" }); },
    commands_build_options_n: function () { return intl.formatMessage({ id: "commands_build_options_n", defaultMessage: "Skip code generation" }); },
    commands_build_options_w: function () { return intl.formatMessage({ id: "commands_build_options_w", defaultMessage: "Automatically rebuild when changes are made (default: false)" }); },
    commands_build_options_s: function () { return intl.formatMessage({ id: "commands_build_options_s", defaultMessage: "Strategy to use for building the wrapper" }); },
    commands_build_options_s_strategy: function () { return intl.formatMessage({ id: "commands_build_options_s_strategy", defaultMessage: "strategy" }); },
    commands_build_info_interface_no_strategy: function () { return intl.formatMessage({ id: "commands_build_info_interface_no_strategy", defaultMessage: "Interface projects do not use build strategies. Building without a strategy..." }); },
    commands_infra_description: function () { return intl.formatMessage({ id: "commands_infra_description", defaultMessage: "Modular Infrastructure-As-Code Orchestrator" }); },
    commands_infra_actions_subtitle: function () { return intl.formatMessage({ id: "commands_infra_actions_subtitle", defaultMessage: "Infra allows you to execute the following commands:" }); },
    commands_infra_options_options: function () { return intl.formatMessage({ id: "commands_infra_options_options", defaultMessage: "options" }); },
    commands_infra_options_i_node: function () { return intl.formatMessage({ id: "commands_infra_options_i_node", defaultMessage: "node" }); },
    commands_infra_options_h: function () { return intl.formatMessage({ id: "commands_infra_options_h", defaultMessage: "Show usage information" }); },
    commands_infra_options_o: function () { return intl.formatMessage({ id: "commands_infra_options_o", defaultMessage: "Use only specified modules" }); },
    commands_infra_options_o_module: function () { return intl.formatMessage({ id: "commands_infra_options_o_module", defaultMessage: "module" }); },
    commands_infra_options_d: function () { return intl.formatMessage({ id: "commands_infra_options_d", defaultMessage: "Run in detached mode" }); },
    commands_infra_options_m_path: function () { return intl.formatMessage({ id: "commands_infra_options_m_path", defaultMessage: "path" }); },
    commands_infra_options_m: function (options) { return intl.formatMessage({ id: "commands_infra_options_m", defaultMessage: "Path to the Polywrap Infra manifest file (default: {default})" }, options); },
    commands_infra_command_up: function () { return intl.formatMessage({ id: "commands_infra_command_up", defaultMessage: "Start Polywrap infrastructure" }); },
    commands_infra_command_down: function () { return intl.formatMessage({ id: "commands_infra_command_down", defaultMessage: "Stop Polywrap infrastructure" }); },
    commands_infra_command_vars: function () { return intl.formatMessage({ id: "commands_infra_command_vars", defaultMessage: "Show Polywrap infrastructure's required .env variables" }); },
    commands_infra_command_config: function () { return intl.formatMessage({ id: "commands_infra_command_config", defaultMessage: "Validate and display Polywrap infrastructure's bundled docker-compose manifest" }); },
    commands_infra_error_never: function () { return intl.formatMessage({ id: "commands_infra_error_never", defaultMessage: "This should never happen..." }); },
    commands_infra_error_noCommand: function () { return intl.formatMessage({ id: "commands_infra_error_noCommand", defaultMessage: "No command given" }); },
    commands_infra_error_unrecognizedCommand: function (options) { return intl.formatMessage({ id: "commands_infra_error_unrecognizedCommand", defaultMessage: "Unrecognized command: {command}" }, options); },
    commands_infra_error_noModulesMatch: function (options) { return intl.formatMessage({ id: "commands_infra_error_noModulesMatch", defaultMessage: "{modules} did not match any module names" }, options); },
    commands_infra_error_noModulesDeclared: function () { return intl.formatMessage({ id: "commands_infra_error_noModulesDeclared", defaultMessage: "No modules declared" }); },
    commands_infra_modulesUsed_text: function () { return intl.formatMessage({ id: "commands_infra_modulesUsed_text", defaultMessage: "Using infra modules" }); },
    commands_infra_options_command: function () { return intl.formatMessage({ id: "commands_infra_options_command", defaultMessage: "command" }); },
    commands_infra_options_start: function () { return intl.formatMessage({ id: "commands_infra_options_start", defaultMessage: "Startup the test env" }); },
    commands_infra_options_stop: function () { return intl.formatMessage({ id: "commands_infra_options_stop", defaultMessage: "Shutdown the test env" }); },
    commands_infra_options_env_vars: function () { return intl.formatMessage({ id: "commands_infra_options_env_vars", defaultMessage: "Show environment variables" }); },
    commands_infra_shutdown_error: function () { return intl.formatMessage({ id: "commands_infra_shutdown_error", defaultMessage: "Failed to shutdown test environment" }); },
    commands_infra_shutdown_text: function () { return intl.formatMessage({ id: "commands_infra_shutdown_text", defaultMessage: "Shutting down test environment..." }); },
    commands_infra_shutdown_warning: function () { return intl.formatMessage({ id: "commands_infra_shutdown_warning", defaultMessage: "Warning shutting down test environment" }); },
    commands_infra_startup_error: function () { return intl.formatMessage({ id: "commands_infra_startup_error", defaultMessage: "Failed to start test environment" }); },
    commands_infra_startup_text: function () { return intl.formatMessage({ id: "commands_infra_startup_text", defaultMessage: "Starting test environment..." }); },
    commands_infra_startup_warning: function () { return intl.formatMessage({ id: "commands_infra_startup_warning", defaultMessage: "Warning starting test environment" }); },
    commands_infra_vars_text: function () { return intl.formatMessage({ id: "commands_infra_vars_text", defaultMessage: "Extracting environment variables" }); },
    commands_infra_vars_warning: function () { return intl.formatMessage({ id: "commands_infra_vars_warning", defaultMessage: "Warning extracting environment variables" }); },
    commands_infra_vars_error: function () { return intl.formatMessage({ id: "commands_infra_vars_error", defaultMessage: "Error extracting environment variables" }); },
    commands_infra_manifest_text: function () { return intl.formatMessage({ id: "commands_infra_manifest_text", defaultMessage: "Aggregating manifest" }); },
    commands_infra_manifest_warning: function () { return intl.formatMessage({ id: "commands_infra_manifest_warning", defaultMessage: "Warning aggregating manifest" }); },
    commands_infra_manifest_error: function () { return intl.formatMessage({ id: "commands_infra_manifest_error", defaultMessage: "Error aggregating manifest" }); },
    commands_build_uriViewers: function () { return intl.formatMessage({ id: "commands_build_uriViewers", defaultMessage: "URI Viewers" }); },
    commands_deploy_description: function () { return intl.formatMessage({ id: "commands_deploy_description", defaultMessage: "Deploys Polywrap Projects" }); },
    commands_deploy_options_options: function () { return intl.formatMessage({ id: "commands_deploy_options_options", defaultMessage: "options" }); },
    commands_deploy_options_o_path: function () { return intl.formatMessage({ id: "commands_deploy_options_o_path", defaultMessage: "path" }); },
    commands_deploy_options_o_string: function () { return intl.formatMessage({ id: "commands_deploy_options_o_string", defaultMessage: "string" }); },
    commands_deploy_options_h: function () { return intl.formatMessage({ id: "commands_deploy_options_h", defaultMessage: "Show usage information" }); },
    commands_deploy_options_m: function (options) { return intl.formatMessage({ id: "commands_deploy_options_m", defaultMessage: "Path to the Polywrap Deploy manifest file (default: {default})" }, options); },
    commands_deploy_options_o: function () { return intl.formatMessage({ id: "commands_deploy_options_o", defaultMessage: "Output file path for the deploy result" }); },
    commands_deploy_options_n: function () { return intl.formatMessage({ id: "commands_deploy_options_n", defaultMessage: "Name of the deployment to execute" }); },
    commands_deploy_options_c: function () { return intl.formatMessage({ id: "commands_deploy_options_c", defaultMessage: "Argument for deployment's publish step, in case deploy step is absent" }); },
    commands_deploy_options_p: function () { return intl.formatMessage({ id: "commands_deploy_options_p", defaultMessage: "Path to the build directory" }); },
    commands_deploy_error_manifestPathMissing: function (options) { return intl.formatMessage({ id: "commands_deploy_error_manifestPathMissing", defaultMessage: "{option} option missing {argument} argument" }, options); },
    commands_deploy_error_pathMissing: function (options) { return intl.formatMessage({ id: "commands_deploy_error_pathMissing", defaultMessage: "{option} option missing {argument} argument" }, options); },
    commands_deploy_error_nameMissing: function (options) { return intl.formatMessage({ id: "commands_deploy_error_nameMissing", defaultMessage: "{option} option missing {argument} argument" }, options); },
    commands_deploy_error_cidMissing: function (options) { return intl.formatMessage({ id: "commands_deploy_error_cidMissing", defaultMessage: "{option} option missing {argument} argument" }, options); },
    commands_codegen_description: function () { return intl.formatMessage({ id: "commands_codegen_description", defaultMessage: "Generate Code For Polywrap Projects" }); },
    commands_codegen_error_domain: function () { return intl.formatMessage({ id: "commands_codegen_error_domain", defaultMessage: "domain" }); },
    commands_codegen_error_optionMissingArgument: function (options) { return intl.formatMessage({ id: "commands_codegen_error_optionMissingArgument", defaultMessage: "{option} option missing {argument} argument" }, options); },
    commands_codegen_options_codegen: function (options) { return intl.formatMessage({ id: "commands_codegen_options_codegen", defaultMessage: "Output directory for the generated code (default: {default})" }, options); },
    commands_codegen_options_e: function () { return intl.formatMessage({ id: "commands_codegen_options_e", defaultMessage: "ENS address to lookup external schemas (default: 0x0000...2e1e)" }); },
    commands_codegen_options_e_address: function () { return intl.formatMessage({ id: "commands_codegen_options_e_address", defaultMessage: "address" }); },
    commands_codegen_options_h: function () { return intl.formatMessage({ id: "commands_codegen_options_h", defaultMessage: "Show usage information" }); },
    commands_codegen_options_s: function () { return intl.formatMessage({ id: "commands_codegen_options_s", defaultMessage: "Path to a custom generation script (JavaScript | TypeScript)" }); },
    commands_codegen_options_i: function () { return intl.formatMessage({ id: "commands_codegen_options_i", defaultMessage: "IPFS node to load external schemas (default: ipfs.io & localhost)" }); },
    commands_codegen_options_i_node: function () { return intl.formatMessage({ id: "commands_codegen_options_i_node", defaultMessage: "node" }); },
    commands_codegen_options_m: function (options) { return intl.formatMessage({ id: "commands_codegen_options_m", defaultMessage: "Path to the Polywrap manifest file (default: {default})" }, options); },
    commands_codegen_options_o: function () { return intl.formatMessage({ id: "commands_codegen_options_o", defaultMessage: "Output directory for custom generated types (default: 'types/')" }); },
    commands_codegen_options_o_path: function () { return intl.formatMessage({ id: "commands_codegen_options_o_path", defaultMessage: "path" }); },
    commands_codegen_success: function () { return intl.formatMessage({ id: "commands_codegen_success", defaultMessage: "Types were generated successfully" }); },
    commands_codegen_options_publish: function (options) { return intl.formatMessage({ id: "commands_codegen_options_publish", defaultMessage: "Output path for the built schema and manifest (default: {default})" }, options); },
    commands_docgen_description: function () { return intl.formatMessage({ id: "commands_docgen_description", defaultMessage: "Generate wrapper documentation" }); },
    commands_docgen_success: function () { return intl.formatMessage({ id: "commands_docgen_success", defaultMessage: "Docs were generated successfully" }); },
    commands_docgen_default: function () { return intl.formatMessage({ id: "commands_docgen_default", defaultMessage: "default" }); },
    commands_docgen_options_c: function (options) { return intl.formatMessage({ id: "commands_docgen_options_c", defaultMessage: "Output directory for generated docs (default: {default})" }, options); },
    commands_docgen_options_m: function (options) { return intl.formatMessage({ id: "commands_docgen_options_m", defaultMessage: "Path to the project manifest file (default: {default})" }, options); },
    commands_docgen_options_schema: function () { return intl.formatMessage({ id: "commands_docgen_options_schema", defaultMessage: "Generate GraphQL schema" }); },
    commands_docgen_options_markdown: function (options) { return intl.formatMessage({ id: "commands_docgen_options_markdown", defaultMessage: "Generate {framework} markdown" }, options); },
    commands_docgen_options_i: function () { return intl.formatMessage({ id: "commands_docgen_options_i", defaultMessage: "Also generate docs for dependencies" }); },
    commands_docgen_error_manifestNotFound: function (options) { return intl.formatMessage({ id: "commands_docgen_error_manifestNotFound", defaultMessage: "Manifest not found. Search paths used: {paths}" }, options); },
    commands_docgen_error_projectLoadFailed: function (options) { return intl.formatMessage({ id: "commands_docgen_error_projectLoadFailed", defaultMessage: "Could not load project form the given manifest. Manifest: `{manifestFile}`" }, options); },
    commands_create_description: function () { return intl.formatMessage({ id: "commands_create_description", defaultMessage: "Create New Projects" }); },
    commands_create_directoryExists: function (options) { return intl.formatMessage({ id: "commands_create_directoryExists", defaultMessage: "Directory with name {dir} already exists" }, options); },
    commands_create_error_commandFail: function (options) { return intl.formatMessage({ id: "commands_create_error_commandFail", defaultMessage: "Command failed: {error}" }, options); },
    commands_create_error_noCommand: function () { return intl.formatMessage({ id: "commands_create_error_noCommand", defaultMessage: "Please provide a command" }); },
    commands_create_error_noLang: function () { return intl.formatMessage({ id: "commands_create_error_noLang", defaultMessage: "Please provide a language" }); },
    commands_create_error_noName: function () { return intl.formatMessage({ id: "commands_create_error_noName", defaultMessage: "Please provide a project name" }); },
    commands_create_error_outputDirMissingPath: function (options) { return intl.formatMessage({ id: "commands_create_error_outputDirMissingPath", defaultMessage: "{option} option missing {argument} argument" }, options); },
    commands_create_error_unrecognizedCommand: function () { return intl.formatMessage({ id: "commands_create_error_unrecognizedCommand", defaultMessage: "Unrecognized command" }); },
    commands_create_error_unrecognizedLanguage: function () { return intl.formatMessage({ id: "commands_create_error_unrecognizedLanguage", defaultMessage: "Unrecognized language" }); },
    commands_create_options_command: function () { return intl.formatMessage({ id: "commands_create_options_command", defaultMessage: "command" }); },
    commands_create_options_commands: function () { return intl.formatMessage({ id: "commands_create_options_commands", defaultMessage: "Commands" }); },
    commands_create_options_createApp: function () { return intl.formatMessage({ id: "commands_create_options_createApp", defaultMessage: "Create a Polywrap application" }); },
    commands_create_options_createPlugin: function () { return intl.formatMessage({ id: "commands_create_options_createPlugin", defaultMessage: "Create a Polywrap plugin" }); },
    commands_create_options_createProject: function () { return intl.formatMessage({ id: "commands_create_options_createProject", defaultMessage: "Create a Polywrap wasm wrapper" }); },
    commands_create_options_h: function () { return intl.formatMessage({ id: "commands_create_options_h", defaultMessage: "Show usage information" }); },
    commands_create_options_lang: function () { return intl.formatMessage({ id: "commands_create_options_lang", defaultMessage: "lang" }); },
    commands_create_options_langs: function () { return intl.formatMessage({ id: "commands_create_options_langs", defaultMessage: "langs" }); },
    commands_create_options_o: function () { return intl.formatMessage({ id: "commands_create_options_o", defaultMessage: "Output directory for the new project" }); },
    commands_create_options_o_path: function () { return intl.formatMessage({ id: "commands_create_options_o_path", defaultMessage: "path" }); },
    commands_create_options_projectName: function () { return intl.formatMessage({ id: "commands_create_options_projectName", defaultMessage: "project-name" }); },
    commands_create_overwritePrompt: function () { return intl.formatMessage({ id: "commands_create_overwritePrompt", defaultMessage: "Do you want to overwrite this directory?" }); },
    commands_create_overwriting: function (options) { return intl.formatMessage({ id: "commands_create_overwriting", defaultMessage: "Overwriting {dir}..." }, options); },
    commands_create_readyApp: function () { return intl.formatMessage({ id: "commands_create_readyApp", defaultMessage: "You are ready to build an app using Polywrap" }); },
    commands_create_readyPlugin: function () { return intl.formatMessage({ id: "commands_create_readyPlugin", defaultMessage: "You are ready to build a plugin into a Polywrap" }); },
    commands_create_readyProtocol: function () { return intl.formatMessage({ id: "commands_create_readyProtocol", defaultMessage: "You are ready to turn your protocol into a Polywrap" }); },
    commands_create_settingUp: function () { return intl.formatMessage({ id: "commands_create_settingUp", defaultMessage: "Setting everything up..." }); },
    commands_run_options_workflow: function () { return intl.formatMessage({ id: "commands_run_options_workflow", defaultMessage: "workflow" }); },
    commands_run_options_workflowScript: function () { return intl.formatMessage({ id: "commands_run_options_workflowScript", defaultMessage: "Path to workflow script" }); },
    commands_run_options_outputFilePath: function () { return intl.formatMessage({ id: "commands_run_options_outputFilePath", defaultMessage: "output-file-path" }); },
    commands_run_options_validateScript: function () { return intl.formatMessage({ id: "commands_run_options_validateScript", defaultMessage: "Validate the output of the workflow jobs" }); },
    commands_run_options_validate: function () { return intl.formatMessage({ id: "commands_run_options_validate", defaultMessage: "cue-file" }); },
    commands_run_options_outputFile: function () { return intl.formatMessage({ id: "commands_run_options_outputFile", defaultMessage: "Output file path for the workflow result" }); },
    commands_run_options_m_path: function () { return intl.formatMessage({ id: "commands_run_options_m_path", defaultMessage: "path" }); },
    commands_run_options_m: function (options) { return intl.formatMessage({ id: "commands_run_options_m", defaultMessage: "Path to the Polywrap Workflow manifest file (default: {default})" }, options); },
    commands_run_options_jobIds: function () { return intl.formatMessage({ id: "commands_run_options_jobIds", defaultMessage: "jobs" }); },
    commands_run_options_jobs: function () { return intl.formatMessage({ id: "commands_run_options_jobs", defaultMessage: "Specify ids of jobs that you want to run" }); },
    commands_run_error_validatorNotFound: function (options) { return intl.formatMessage({ id: "commands_run_error_validatorNotFound", defaultMessage: "validate script not found at: {path}" }, options); },
    commands_run_error_outputFileMissing: function (options) { return intl.formatMessage({ id: "commands_run_error_outputFileMissing", defaultMessage: "{option} option missing {argument} argument" }, options); },
    commands_run_error_clientConfigMissingPath: function (options) { return intl.formatMessage({ id: "commands_run_error_clientConfigMissingPath", defaultMessage: "{option} option missing {argument} argument" }, options); },
    commands_run_error_clientConfigModuleMissingExport: function (options) { return intl.formatMessage({ id: "commands_run_error_clientConfigModuleMissingExport", defaultMessage: "Custom client config module missing named export 'getClientConfig' at {module}" }, options); },
    commands_run_error_clientConfigInvalidFileExt: function (options) { return intl.formatMessage({ id: "commands_run_error_clientConfigInvalidFileExt", defaultMessage: "Custom client config file: {module} must be a JS/TS file" }, options); },
    commands_run_error_clientConfigNotObject: function () { return intl.formatMessage({ id: "commands_run_error_clientConfigNotObject", defaultMessage: "Custom client config must be an object" }); },
    commands_run_error_redirectsExportNotArray: function () { return intl.formatMessage({ id: "commands_run_error_redirectsExportNotArray", defaultMessage: "Exported redirects must be an array" }); },
    commands_run_error_redirectsItemNotValid: function (options) { return intl.formatMessage({ id: "commands_run_error_redirectsItemNotValid", defaultMessage: "Redirect at index {index} must be an object with properties 'from' and 'to'" }, options); },
    commands_run_error_redirectsItemFromNotString: function (options) { return intl.formatMessage({ id: "commands_run_error_redirectsItemFromNotString", defaultMessage: "Redirect property 'from' at index {index} must be a valid wrap:// URI string" }, options); },
    commands_run_error_redirectsItemToNotStringOrObject: function (options) { return intl.formatMessage({ id: "commands_run_error_redirectsItemToNotStringOrObject", defaultMessage: "Redirect property 'to' at index {index} must be a valid wrap:// URI string, or a plugin" }, options); },
    commands_run_error_redirectsItemToNotValidPlugin: function (options) { return intl.formatMessage({ id: "commands_run_error_redirectsItemToNotValidPlugin", defaultMessage: "Redirect property 'to' at index {index} must be a valid plugin instance" }, options); },
    commands_run_error_pluginsExportNotArray: function () { return intl.formatMessage({ id: "commands_run_error_pluginsExportNotArray", defaultMessage: "Exported plugins must be an array" }); },
    commands_run_error_pluginsItemNotObject: function (options) { return intl.formatMessage({ id: "commands_run_error_pluginsItemNotObject", defaultMessage: "Plugin at index {index} must be an object with properties 'uri' and 'plugin'" }, options); },
    commands_run_error_pluginsItemUriNotString: function (options) { return intl.formatMessage({ id: "commands_run_error_pluginsItemUriNotString", defaultMessage: "Plugin property 'uri' at index {index} must be a valid wrap:// URI string" }, options); },
    commands_run_error_pluginsItemPluginNotObject: function (options) { return intl.formatMessage({ id: "commands_run_error_pluginsItemPluginNotObject", defaultMessage: "Plugin property 'plugin' at index {index} must be an object with properties 'factory' and 'manifest'" }, options); },
    commands_run_error_pluginsItemPluginFactoryNotFunction: function (options) { return intl.formatMessage({ id: "commands_run_error_pluginsItemPluginFactoryNotFunction", defaultMessage: "Plugin property 'plugin.factory' at index {index} must be a function" }, options); },
    commands_run_error_pluginsItemPluginManifestNotObject: function (options) { return intl.formatMessage({ id: "commands_run_error_pluginsItemPluginManifestNotObject", defaultMessage: "Plugin property 'plugin.manifest' at index {index} must be an object" }, options); },
    commands_run_error_interfacesExportNotArray: function () { return intl.formatMessage({ id: "commands_run_error_interfacesExportNotArray", defaultMessage: "Exported interfaces must be an array" }); },
    commands_run_error_interfacesItemNotObject: function (options) { return intl.formatMessage({ id: "commands_run_error_interfacesItemNotObject", defaultMessage: "Interface at index {index} must be an object with properties 'interface' and 'implementations'" }, options); },
    commands_run_error_interfacesItemInterfaceNotString: function (options) { return intl.formatMessage({ id: "commands_run_error_interfacesItemInterfaceNotString", defaultMessage: "Interface property 'interface' at index {index} must be a valid wrap:// URI string" }, options); },
    commands_run_error_interfacesItemImplementationsNotArray: function (options) { return intl.formatMessage({ id: "commands_run_error_interfacesItemImplementationsNotArray", defaultMessage: "Interface property 'implementations' at index {index} must be an array" }, options); },
    commands_run_error_interfacesItemImplementationsEmpty: function (options) { return intl.formatMessage({ id: "commands_run_error_interfacesItemImplementationsEmpty", defaultMessage: "Interface property 'implementations' at index {index} must not be an empty array" }, options); },
    commands_run_error_interfacesItemImplementationsItemNotString: function (options) { return intl.formatMessage({ id: "commands_run_error_interfacesItemImplementationsItemNotString", defaultMessage: "Implementation at index ({index}, {implementationIndex}) must be a valid wrap:// URI string" }, options); },
    commands_run_error_envsExportNotArray: function () { return intl.formatMessage({ id: "commands_run_error_envsExportNotArray", defaultMessage: "Exported envs must be an array" }); },
    commands_run_error_envsItemNotObject: function (options) { return intl.formatMessage({ id: "commands_run_error_envsItemNotObject", defaultMessage: "Env at index {index} must be an object with properties 'uri'" }, options); },
    commands_run_error_envsItemUriNotString: function (options) { return intl.formatMessage({ id: "commands_run_error_envsItemUriNotString", defaultMessage: "Env property 'uri' at index {index} must be a valid wrap:// URI string" }, options); },
    commands_run_error_envsItemModuleNotObject: function (options) { return intl.formatMessage({ id: "commands_run_error_envsItemModuleNotObject", defaultMessage: "Env property 'env' at index {index} must be an object" }, options); },
    commands_run_description: function () { return intl.formatMessage({ id: "commands_run_description", defaultMessage: "Runs Workflows" }); },
    commands_run_error_missingScript: function (options) { return intl.formatMessage({ id: "commands_run_error_missingScript", defaultMessage: "Required argument {script} is missing" }, options); },
    commands_run_error_noApi: function () { return intl.formatMessage({ id: "commands_run_error_noApi", defaultMessage: "API needs to be initialized" }); },
    commands_run_error_readFail: function (options) { return intl.formatMessage({ id: "commands_run_error_readFail", defaultMessage: "Failed to read query {query}" }, options); },
    commands_run_error_unsupportedOutputFileExt: function (options) { return intl.formatMessage({ id: "commands_run_error_unsupportedOutputFileExt", defaultMessage: "Unsupported outputFile extention: {outputFileExt}" }, options); },
    commands_run_error_cueDoesNotExist: function () { return intl.formatMessage({ id: "commands_run_error_cueDoesNotExist", defaultMessage: "Require cue to run validator, checkout https://cuelang.org/ for more information" }); },
    commands_run_error_noWorkflowScriptFound: function (options) { return intl.formatMessage({ id: "commands_run_error_noWorkflowScriptFound", defaultMessage: "Workflow script not found at path: {path}" }, options); },
    commands_run_error_noTestEnvFound: function () { return intl.formatMessage({ id: "commands_run_error_noTestEnvFound", defaultMessage: "polywrap test-env not found, please run 'polywrap infra up --modules=eth-ens-ipfs'" }); },
    commands_polywrap_error_notACommand: function () { return intl.formatMessage({ id: "commands_polywrap_error_notACommand", defaultMessage: "is not a command" }); },
    commands_polywrap_helpPrompt: function (options) { return intl.formatMessage({ id: "commands_polywrap_helpPrompt", defaultMessage: "Type {command} to view common commands" }, options); },
    commands_manifest_description: function () { return intl.formatMessage({ id: "commands_manifest_description", defaultMessage: "Inspect & Migrade Polywrap Manifests" }); },
    commands_manifest_options_m: function (options) { return intl.formatMessage({ id: "commands_manifest_options_m", defaultMessage: "Path to the manifest file (default: {default})" }, options); },
    commands_manifest_options_f: function () { return intl.formatMessage({ id: "commands_manifest_options_f", defaultMessage: "Target format to migrate to (defaults to latest)" }); },
    commands_manifest_options_t: function (options) { return intl.formatMessage({ id: "commands_manifest_options_t", defaultMessage: "Type of manifest file to migrate (default: {default})" }, options); },
    commands_manifest_options_m_path: function () { return intl.formatMessage({ id: "commands_manifest_options_m_path", defaultMessage: "path" }); },
    commands_manifest_options_m_format: function () { return intl.formatMessage({ id: "commands_manifest_options_m_format", defaultMessage: "format" }); },
    commands_manifest_options_t_type: function () { return intl.formatMessage({ id: "commands_manifest_options_t_type", defaultMessage: "type" }); },
    commands_manifest_command_s: function () { return intl.formatMessage({ id: "commands_manifest_command_s", defaultMessage: "Prints out the schema for the current manifest format." }); },
    commands_manifest_command_m: function () { return intl.formatMessage({ id: "commands_manifest_command_m", defaultMessage: "Migrates the polywrap project manifest to the latest version." }); },
    commands_manifest_command_s_option_r: function () { return intl.formatMessage({ id: "commands_manifest_command_s_option_r", defaultMessage: "Output raw JSON Schema" }); },
    commands_manifest_command_m_preserveManifestMessage: function (options) { return intl.formatMessage({ id: "commands_manifest_command_m_preserveManifestMessage", defaultMessage: "Saved previous version of manifest to {preservedFilePath}" }, options); },
    commands_manifest_command_m_migrateManifestMessage: function (options) { return intl.formatMessage({ id: "commands_manifest_command_m_migrateManifestMessage", defaultMessage: "Migrating {manifestFile} to version {version}" }, options); },
    commands_manifest_formatError: function (options) { return intl.formatMessage({ id: "commands_manifest_formatError", defaultMessage: "Unsupported manifest format. Please make sure that you have the 'format' field present in {fileName} with one of the following values: {values}" }, options); },
    commands_manifest_migrate_targetFormatError: function (options) { return intl.formatMessage({ id: "commands_manifest_migrate_targetFormatError", defaultMessage: "Unsupported target format. Supported formats: {formats}" }, options); },
    commands_manifest_projectTypeError: function () { return intl.formatMessage({ id: "commands_manifest_projectTypeError", defaultMessage: "Unsupported project type." }); },
    lib_codeGenerator_genCodeError: function () { return intl.formatMessage({ id: "lib_codeGenerator_genCodeError", defaultMessage: "Failed to generate types" }); },
    lib_codeGenerator_genCodeText: function () { return intl.formatMessage({ id: "lib_codeGenerator_genCodeText", defaultMessage: "Generate types" }); },
    lib_codeGenerator_genCodeWarning: function () { return intl.formatMessage({ id: "lib_codeGenerator_genCodeWarning", defaultMessage: "Warnings while generating types" }); },
    lib_codeGenerator_genTemplateStep: function (options) { return intl.formatMessage({ id: "lib_codeGenerator_genTemplateStep", defaultMessage: "Generating types from {path}" }, options); },
    lib_codeGenerator_wrongGenFile: function () { return intl.formatMessage({ id: "lib_codeGenerator_wrongGenFile", defaultMessage: "The generation file provided is wrong." }); },
    lib_codeGenerator_templateNoModify: function () { return intl.formatMessage({ id: "lib_codeGenerator_templateNoModify", defaultMessage: "NOTE: This is generated by 'polywrap codegen', DO NOT MODIFY" }); },
    lib_codeGenerator_nogenerateBindingMethod: function () { return intl.formatMessage({ id: "lib_codeGenerator_nogenerateBindingMethod", defaultMessage: "The generation file provided doesn't have the 'generateBinding' method." }); },
    lib_codeGenerator_noComposedSchema: function () { return intl.formatMessage({ id: "lib_codeGenerator_noComposedSchema", defaultMessage: "The schema does not exist, please define one." }); },
    lib_codeGenerator_abiMissing: function () { return intl.formatMessage({ id: "lib_codeGenerator_abiMissing", defaultMessage: "The ABI is missing from the composer output." }); },
    lib_compiler_compileError: function () { return intl.formatMessage({ id: "lib_compiler_compileError", defaultMessage: "Failed to compile Polywrap" }); },
    lib_compiler_compileText: function () { return intl.formatMessage({ id: "lib_compiler_compileText", defaultMessage: "Compile Polywrap" }); },
    lib_compiler_compileWarning: function () { return intl.formatMessage({ id: "lib_compiler_compileWarning", defaultMessage: "Warnings while compiling Polywrap" }); },
    lib_compiler_codegenError: function () { return intl.formatMessage({ id: "lib_compiler_codegenError", defaultMessage: "Failed to generate Polywrap schema bindings" }); },
    lib_compiler_codegenText: function () { return intl.formatMessage({ id: "lib_compiler_codegenText", defaultMessage: "Codegen Polywrap schema bindings" }); },
    lib_compiler_codegenWarning: function () { return intl.formatMessage({ id: "lib_compiler_codegenWarning", defaultMessage: "Warnings while generating Polywrap schema bindings" }); },
    lib_compiler_compileWasmModulesError: function () { return intl.formatMessage({ id: "lib_compiler_compileWasmModulesError", defaultMessage: "Failed to compile Wasm modules" }); },
    lib_compiler_compileWasmModulesText: function () { return intl.formatMessage({ id: "lib_compiler_compileWasmModulesText", defaultMessage: "Compile Wasm modules" }); },
    lib_compiler_compileWasmModulesWarning: function () { return intl.formatMessage({ id: "lib_compiler_compileWasmModulesWarning", defaultMessage: "Warnings while compiling Wasm modules" }); },
    lib_compiler_failedAbiReturn: function () { return intl.formatMessage({ id: "lib_compiler_failedAbiReturn", defaultMessage: "Abi composer failed to return a combined abi." }); },
    lib_compiler_noModulesToBuild: function () { return intl.formatMessage({ id: "lib_compiler_noModulesToBuild", defaultMessage: "No modules to build declared." }); },
    lib_compiler_missingModule: function () { return intl.formatMessage({ id: "lib_compiler_missingModule", defaultMessage: "Missing module definition" }); },
    lib_compiler_noInterfaceModule: function () { return intl.formatMessage({ id: "lib_compiler_noInterfaceModule", defaultMessage: "Interfaces cannot have implementation file" }); },
    lib_compiler_step: function () { return intl.formatMessage({ id: "lib_compiler_step", defaultMessage: "Compiling WASM module" }); },
    lib_compiler_noNodeModules: function (options) { return intl.formatMessage({ id: "lib_compiler_noNodeModules", defaultMessage: "could not locate {folder} in parent directories of polywrap manifest" }, options); },
    lib_compiler_noInvoke: function () { return intl.formatMessage({ id: "lib_compiler_noInvoke", defaultMessage: "WASM module is missing the _wrap_invoke export. This should never happen..." }); },
    lib_compiler_invalid_module: function (options) { return intl.formatMessage({ id: "lib_compiler_invalid_module", defaultMessage: "Invalid Wasm module found. {modulePath} is invalid. Error: {error}" }, options); },
    lib_compiler_cannotBuildInterfaceModules: function () { return intl.formatMessage({ id: "lib_compiler_cannotBuildInterfaceModules", defaultMessage: "Cannot build modules for an Interface Polywrap" }); },
    lib_compiler_outputMetadataText: function () { return intl.formatMessage({ id: "lib_compiler_outputMetadataText", defaultMessage: "Metadata written" }); },
    lib_compiler_outputMetadataError: function () { return intl.formatMessage({ id: "lib_compiler_outputMetadataError", defaultMessage: "Failed to output metadata" }); },
    lib_compiler_outputMetadataWarning: function () { return intl.formatMessage({ id: "lib_compiler_outputMetadataWarning", defaultMessage: "Warnings writing metadata" }); },
    lib_compiler_outputMetadataFileText: function (options) { return intl.formatMessage({ id: "lib_compiler_outputMetadataFileText", defaultMessage: "Metadata written to {path}" }, options); },
    lib_schemaComposer_abi_not_found: function (options) { return intl.formatMessage({ id: "lib_schemaComposer_abi_not_found", defaultMessage: "ABI not found at {path}" }, options); },
    lib_schemaComposer_unknown_abi: function (options) { return intl.formatMessage({ id: "lib_schemaComposer_unknown_abi", defaultMessage: "Unknown ABI type at {path}. Supported types: {types}" }, options); },
    lib_schemaComposer_invalid_yaml: function (options) { return intl.formatMessage({ id: "lib_schemaComposer_invalid_yaml", defaultMessage: "Invalid YAML at {path}" }, options); },
    lib_generators_projectGenerator_fallback: function () { return intl.formatMessage({ id: "lib_generators_projectGenerator_fallback", defaultMessage: "Falling back to the local Yarn cache." }); },
    lib_generators_projectGenerator_offline: function () { return intl.formatMessage({ id: "lib_generators_projectGenerator_offline", defaultMessage: "You appear to be offline." }); },
    lib_helpers_manifest_loadError: function (options) { return intl.formatMessage({ id: "lib_helpers_manifest_loadError", defaultMessage: "Failed to load manifest from {path}" }, options); },
    lib_helpers_manifest_loadText: function (options) { return intl.formatMessage({ id: "lib_helpers_manifest_loadText", defaultMessage: "Manifest loaded from {path}" }, options); },
    lib_helpers_manifest_loadWarning: function (options) { return intl.formatMessage({ id: "lib_helpers_manifest_loadWarning", defaultMessage: "Warnings loading manifest from {path}" }, options); },
    lib_helpers_deployManifestExt_loadError: function (options) { return intl.formatMessage({ id: "lib_helpers_deployManifestExt_loadError", defaultMessage: "Failed to load deploy manifest extension from {path}" }, options); },
    lib_helpers_deployManifestExt_loadText: function (options) { return intl.formatMessage({ id: "lib_helpers_deployManifestExt_loadText", defaultMessage: "Load manifest extension from {path}" }, options); },
    lib_helpers_deployManifestExt_loadWarning: function (options) { return intl.formatMessage({ id: "lib_helpers_deployManifestExt_loadWarning", defaultMessage: "No manifest extension found in {path}" }, options); },
    lib_helpers_manifest_outputError: function (options) { return intl.formatMessage({ id: "lib_helpers_manifest_outputError", defaultMessage: "Failed to output manifest to {path}" }, options); },
    lib_helpers_manifest_outputText: function (options) { return intl.formatMessage({ id: "lib_helpers_manifest_outputText", defaultMessage: "Manifest written to {path}" }, options); },
    lib_helpers_manifest_outputWarning: function (options) { return intl.formatMessage({ id: "lib_helpers_manifest_outputWarning", defaultMessage: "Warnings writing manifest to {path}" }, options); },
    lib_helpers_manifest_unableToDump: function (options) { return intl.formatMessage({ id: "lib_helpers_manifest_unableToDump", defaultMessage: "Unable to dump manifest: {manifest}" }, options); },
    lib_helpers_manifest_unableToLoad: function (options) { return intl.formatMessage({ id: "lib_helpers_manifest_unableToLoad", defaultMessage: "Unable to load manifest: {path}" }, options); },
    lib_helpers_copyText: function (options) { return intl.formatMessage({ id: "lib_helpers_copyText", defaultMessage: "Artifacts written to {path}" }, options); },
    lib_helpers_copyError: function (options) { return intl.formatMessage({ id: "lib_helpers_copyError", defaultMessage: "Failed to write build artifacts to {path}" }, options); },
    lib_helpers_copyWarning: function (options) { return intl.formatMessage({ id: "lib_helpers_copyWarning", defaultMessage: "Warnings write build artifacts to {path}" }, options); },
    lib_helpers_docker_copyText: function (options) { return intl.formatMessage({ id: "lib_helpers_docker_copyText", defaultMessage: "Artifacts written to {path} from the image `{image}`" }, options); },
    lib_helpers_docker_couldNotConnect: function () { return intl.formatMessage({ id: "lib_helpers_docker_couldNotConnect", defaultMessage: "Could not connect to the Docker daemon. Is the docker daemon running?" }); },
    lib_helpers_docker_copyError: function (options) { return intl.formatMessage({ id: "lib_helpers_docker_copyError", defaultMessage: "Failed to write build artifacts to {path} from the image `{image}`" }, options); },
    lib_helpers_docker_copyWarning: function (options) { return intl.formatMessage({ id: "lib_helpers_docker_copyWarning", defaultMessage: "Warnings write build artifacts to {path} from the image `{image}`" }, options); },
    lib_helpers_docker_buildText: function (options) { return intl.formatMessage({ id: "lib_helpers_docker_buildText", defaultMessage: "Building source image `{image}` using dockerfile `{dockerfile}` in context `{context}`" }, options); },
    lib_helpers_docker_buildError: function (options) { return intl.formatMessage({ id: "lib_helpers_docker_buildError", defaultMessage: "Error while building source image `{image}` using dockerfile `{dockerfile}` in context `{context}`" }, options); },
    lib_helpers_docker_buildWarning: function (options) { return intl.formatMessage({ id: "lib_helpers_docker_buildWarning", defaultMessage: "Warnings while building image `{image}` using dockerfile `{dockerfile}` in context `{context}`" }, options); },
    lib_helpers_docker_buildVMText: function () { return intl.formatMessage({ id: "lib_helpers_docker_buildVMText", defaultMessage: "Building sources in Docker container`" }); },
    lib_helpers_docker_buildVMError: function () { return intl.formatMessage({ id: "lib_helpers_docker_buildVMError", defaultMessage: "Error while building sources in Docker container" }); },
    lib_helpers_docker_buildVMWarning: function () { return intl.formatMessage({ id: "lib_helpers_docker_buildVMWarning", defaultMessage: "Warnings while building sources in Docker container" }); },
    lib_helpers_buildText: function () { return intl.formatMessage({ id: "lib_helpers_buildText", defaultMessage: "Building sources" }); },
    lib_helpers_buildError: function () { return intl.formatMessage({ id: "lib_helpers_buildError", defaultMessage: "Error while building sources" }); },
    lib_helpers_buildWarning: function () { return intl.formatMessage({ id: "lib_helpers_buildWarning", defaultMessage: "Warnings while building sources" }); },
    lib_helpers_docker_projectFolderMissing: function (options) { return intl.formatMessage({ id: "lib_helpers_docker_projectFolderMissing", defaultMessage: "Build image `{image}` missing /project folder" }, options); },
    lib_helpers_docker_projectBuildFolderMissing: function (options) { return intl.formatMessage({ id: "lib_helpers_docker_projectBuildFolderMissing", defaultMessage: "Build image `{image}` missing build artifact `{artifact}` in folder /project/build" }, options); },
    lib_helpers_parameters_unexpectedValue: function (options) { return intl.formatMessage({ id: "lib_helpers_parameters_unexpectedValue", defaultMessage: "Unexpected value provided for one or more of {options}. See --help for more information." }, options); },
    lib_language_unsupportedManifestLanguage: function (options) { return intl.formatMessage({ id: "lib_language_unsupportedManifestLanguage", defaultMessage: "The manifest's language {language} is not supported. Please use one of the supported lanauges: {supported}" }, options); },
    lib_language_noInterfaceCodegen: function () { return intl.formatMessage({ id: "lib_language_noInterfaceCodegen", defaultMessage: "Code generation cannot be run for Polywrap Interface projects" }); },
    lib_system_env_var_not_found: function (options) { return intl.formatMessage({ id: "lib_system_env_var_not_found", defaultMessage: "Environment variable not found: `{variableName}`" }, options); },
    lib_publishers_ipfsPublisher_urlMalformed: function () { return intl.formatMessage({ id: "lib_publishers_ipfsPublisher_urlMalformed", defaultMessage: "IPFS URL Malformed" }); },
    lib_project_invalid_manifest_language: function (options) { return intl.formatMessage({ id: "lib_project_invalid_manifest_language", defaultMessage: "Unrecognized manifest language `{language}`. Fix: Please modify your polywrap.yaml file to include a valid language field. Supported Manifest Languages: {validTypes}" }, options); },
    lib_project_invalid_manifest_language_pathed: function (options) { return intl.formatMessage({ id: "lib_project_invalid_manifest_language_pathed", defaultMessage: "Unsupported manifest language `{language}`.Debug: No default manifest found at {defaultPath}. Please make contact with the Polywrap CLI development community." }, options); },
    lib_project_language_not_found: function () { return intl.formatMessage({ id: "lib_project_language_not_found", defaultMessage: "Manifest language not found. Please include the `language` property in the manifest file." }); },
    lib_project_app_uri_support: function () { return intl.formatMessage({ id: "lib_project_app_uri_support", defaultMessage: "The app command supports only filesystem URIs for plugins. Examples:" }); },
    lib_project_imported_plugin_manifest_not_found: function (options) { return intl.formatMessage({ id: "lib_project_imported_plugin_manifest_not_found", defaultMessage: "No manifest found for imported plugin namespace `{namespace}` at path `{path}`" }, options); },
    lib_project_invalid_uri: function () { return intl.formatMessage({ id: "lib_project_invalid_uri", defaultMessage: "Invalid URI Received:" }); },
    lib_typescript_notInstalled: function () { return intl.formatMessage({ id: "lib_typescript_notInstalled", defaultMessage: "Your project uses typescript, but it's not installed" }); },
    lib_typescript_tsNodeNotInstalled: function () { return intl.formatMessage({ id: "lib_typescript_tsNodeNotInstalled", defaultMessage: "Your project uses typescript, but ts-node is not installed" }); },
    lib_watcher_alreadyWatching: function (options) { return intl.formatMessage({ id: "lib_watcher_alreadyWatching", defaultMessage: "Watcher session is already in progress. Directory: {dir}" }, options); },
    lib_wasm_rust_invalidModule: function (options) { return intl.formatMessage({ id: "lib_wasm_rust_invalidModule", defaultMessage: "Module paths must point to Cargo.toml files. Found: {path}" }, options); },
    lib_docker_invalidImageId: function (options) { return intl.formatMessage({ id: "lib_docker_invalidImageId", defaultMessage: "Invalid docker image ID returned: {imageId}" }, options); },
    lib_docker_noInstall: function () { return intl.formatMessage({ id: "lib_docker_noInstall", defaultMessage: "Docker executable not found in PATH" }); },
    lib_infra_unrecognizedModule: function (options) { return intl.formatMessage({ id: "lib_infra_unrecognizedModule", defaultMessage: "Unrecognized modules: {modules}. Default modules: {defaultModules}" }, options); },
    lib_wrap_abi_not_found: function () { return intl.formatMessage({ id: "lib_wrap_abi_not_found", defaultMessage: "No WRAP ABI found" }); },
    lib_helpers_wrap_manifest_outputText: function (options) { return intl.formatMessage({ id: "lib_helpers_wrap_manifest_outputText", defaultMessage: "WRAP manifest written in {path}" }, options); },
    lib_helpers_wrap_manifest_outputError: function (options) { return intl.formatMessage({ id: "lib_helpers_wrap_manifest_outputError", defaultMessage: "Error writing WRAP manifest in {path}" }, options); },
    lib_helpers_wrap_manifest_outputWarning: function (options) { return intl.formatMessage({ id: "lib_helpers_wrap_manifest_outputWarning", defaultMessage: "Warning writing WRAP manifest in {path}" }, options); },
    lib_option_defaults_deprecated_project_manifest: function (options) { return intl.formatMessage({ id: "lib_option_defaults_deprecated_project_manifest", defaultMessage: "WARNING: the filename `{fileName}` is deprecated and will be removed from the default project manifest files in the future. Please rename it to `polywrap.yaml`." }, options); }
};
//# sourceMappingURL=types.js.map